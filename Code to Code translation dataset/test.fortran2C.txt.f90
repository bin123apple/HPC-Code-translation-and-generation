SUBROUTINE funnelledPingping(totalReps, dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i integer :: destRank IF (myMPIRank == pingRankA) THEN destRank = pingRankB ELSE IF (myMPIRank == pingRankB) THEN destRank = pingRankA END IF DO repIter = 1, totalReps IF(myMPIRank == pingRankA .or. myMPIRank == pingRankB) THEN DO i = 1,sizeofBuffer pingSendBuf(i) = globalIDarray(myThreadID) END DO CALL MPI_Isend(pingSendBuf, sizeofBuffer, MPI_INTEGER,& destRank, tag, comm, requestID, ierr) CALL MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INTEGER,& destRank, tag, comm, status, ierr) CALL MPI_Wait(requestID, status, ierr) DO i = 1,sizeofBuffer finalRecvBuf(i) = pingRecvBuf(i) END DO END IF END DO END SUBROUTINE funnelledPingping
SUBROUTINE multiplePingping(totalReps, dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i integer :: destRank integer :: lBound, uBound IF (myMPIRank == pingRankA) THEN destRank = pingRankB ELSE IF (myMPIRank == pingRankB) THEN destRank = pingRankA END IF DO repIter = 1,totalReps IF(myMPIRank == pingRankA .or. myMPIRank == pingRankB) THEN lBound = ((myThreadID-1)* dataSize) + 1 uBound = (myThreadID * dataSize) DO i = 1,sizeofBuffer pingSendBuf(i) = globalIDarray(myThreadID) END DO CALL MPI_Isend(pingSendBuf(lBound:uBound), dataSize,& MPI_INTEGER, destRank, myThreadID, comm,& requestID, ierr) CALL MPI_Recv(pingRecvBuf(lBound:uBound), dataSize,& MPI_INTEGER, destRank, myThreadID, comm,& status, ierr) CALL MPI_Wait(requestID, status, ierr) DO i = 1, sizeofBuffer finalRecvBuf(i) = pingRecvBuf(i) END DO END IF END DO END SUBROUTINE multiplePingping
SUBROUTINE allocateData(bufferSize) integer, intent(in) :: bufferSize allocate(pingSendBuf(bufferSize), pingRecvBuf(bufferSize)) allocate(finalRecvBuf(bufferSize)) END SUBROUTINE allocateData
SUBROUTINE freeData() deallocate(pingSendBuf, pingRecvBuf) deallocate(finalRecvBuf) END SUBROUTINE freeData
SUBROUTINE testPingPing(sizeofBuffer, dataSize) integer, intent(in) :: sizeofBuffer, dataSize integer :: otherPingRank, i logical :: testFlag, reduceFlag testFlag = .true. IF (myMPIRank == pingRankA .or. myMPIRank == pingRankB) THEN allocate(testBuf(sizeofBuffer)) IF (myMPIRank == pingRankA) THEN otherPingRank = pingRankB ELSE IF (myMPIRank == pingRankB) THEN otherPingRank = pingRankA END IF DO i = 1, sizeofBuffer testBuf(i) = (otherPingRank * numThreads) + myThreadID END DO DO i = 1, sizeofBuffer IF (testBuf(i) /= finalRecvBuf(i)) THEN testFlag = .false. END IF END DO deallocate(testBuf) END IF CALL MPI_Reduce(testFlag, reduceFlag, 1, MPI_LOGICAL, & MPI_LAND, 0, comm, ierr) IF (myMPIRank == 0) THEN CALL setTestOutcome(reduceFlag) END IF END SUBROUTINE testPingPing
SUBROUTINE pingPong(benchmarkType) integer, intent(in) :: benchmarkType integer :: dataSizeIter logical :: sameNode pingRank = PPRanks(1) pongRank = PPRanks(2) sameNode = compareProcNames(pingRank,pongRank) IF (myMPIRank == 0) THEN CALL printNodeReport(sameNode,pingRank,pongRank) CALL printBenchHeader() END IF repsToDo = defaultReps dataSizeIter = minDataSize DO WHILE (dataSizeIter <= maxDataSize) sizeofBuffer = dataSizeIter*numThreads CALL allocateData(sizeofBuffer) IF (benchmarkType == MASTERONLY) THEN CALL masteronlyPingpong(warmUpIters, dataSizeIter) ELSE IF (benchmarkType == FUNNELLED) THEN CALL funnelledPingpong(warmUpIters, dataSizeIter) ELSE IF (benchmarkType == MULTIPLE) THEN CALL multiplePingpong(warmUpIters, dataSizeIter) END IF CALL testPingpong(sizeofBuffer, dataSizeIter) benchComplete = .false. DO WHILE (benchComplete .NEQV. .true.) CALL MPI_Barrier(comm, ierr) startTime = MPI_Wtime() IF (benchmarkType == MASTERONLY) THEN CALL masteronlyPingpong(repsToDo, dataSizeIter) ELSE IF (benchmarkType == FUNNELLED) THEN CALL funnelledPingpong(repsToDo, dataSizeIter) ELSE IF (benchmarkType == MULTIPLE) THEN CALL multiplePingpong(repsToDo, dataSizeIter) END IF CALL MPI_Barrier(comm, ierr) finishTime = MPI_Wtime() totalTime = finishTime - startTime if (myMPIRank==0) then benchComplete = repTimeCheck(totalTime, repsToDo) end if call MPI_Bcast(benchComplete, 1, MPI_INTEGER, 0, comm, ierr) call MPI_Bcast(repsToDo, 1, MPI_INTEGER, 0, comm, ierr) END DO IF (myMPIRank == 0) THEN CALL setReportParams(dataSizeIter,repsToDo,totalTime) CALL printReport() END IF CALL freeData() dataSizeIter = dataSizeIter * 2 END DO END SUBROUTINE pingPong
SUBROUTINE masteronlyPingpong(totalReps, dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i DO repIter = 1, totalReps IF (myMPIRank == pingRank) THEN DO i = 1,sizeofBuffer pingSendBuf(i) = globalIDarray(myThreadID) ENDDO CALL MPI_Send(pingSendBuf, sizeofBuffer, MPI_INTEGER,& pongRank, tag, comm, ierr) CALL MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INTEGER,& pongRank, tag, comm, status, ierr) DO i = 1,sizeofBuffer finalRecvBuf(i) = pongRecvBuf(i) ENDDO ELSEIF (myMPIRank == pongRank) THEN CALL MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INTEGER, & pingRank, tag, comm, status, ierr) DO i = 1,sizeofBuffer pongSendBuf(i) = pingRecvBuf(i) END DO CALL MPI_Send(pongSendBuf, sizeofBuffer, MPI_INTEGER, & pingRank, tag, comm, ierr) END IF END DO END SUBROUTINE masteronlyPingpong
SUBROUTINE funnelledPingpong(totalReps, dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i DO repIter = 1, totalReps IF (myMPIRank == pingRank) THEN DO i = 1,sizeofBuffer pingSendBuf(i) = globalIDarray(myThreadID) ENDDO CALL MPI_Send(pingSendBuf, sizeofBuffer, MPI_INTEGER,& pongRank, tag, comm, ierr) CALL MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INTEGER,& pongRank, tag, comm, status, ierr) DO i = 1,sizeofBuffer finalRecvBuf(i) = pongRecvBuf(i) ENDDO ELSEIF (myMPIRank == pongRank) THEN CALL MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INTEGER, & pingRank, tag, comm, status, ierr) DO i = 1,sizeofBuffer pongSendBuf(i) = pingRecvBuf(i) END DO CALL MPI_Send(pongSendBuf, sizeofBuffer, MPI_INTEGER, & pingRank, tag, comm, ierr) END IF END DO END SUBROUTINE funnelledPingpong
SUBROUTINE multiplePingpong(totalReps, dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i integer :: lBound, uBound DO repIter = 1, totalReps IF (myMPIRank == pingRank) THEN lBound = ((myThreadID-1)* dataSize) + 1 uBound = (myThreadID * dataSize) DO i = 1,sizeofBuffer pingSendBuf(i) = globalIDarray(myThreadID) ENDDO CALL MPI_Send(pingSendBuf(lBound:uBound), dataSize,& MPI_INTEGER, pongRank, myThreadID, comm, ierr) CALL MPI_Recv(pongRecvBuf(lBound:uBound), dataSize, & MPI_INTEGER, pongRank, myThreadID, comm, & status, ierr) DO i = 1,sizeofBuffer finalRecvBuf(i) = pongRecvBuf(i) ENDDO ELSEIF (myMPIRank == pongRank) THEN lBound = ((myThreadID-1)* dataSize)+1 uBound = (myThreadID * dataSize) CALL MPI_Recv(pingRecvBuf(lBound:uBound), dataSize, & MPI_INTEGER, pingRank, myThreadID, comm, & status, ierr) DO i = 1,sizeofBuffer pongSendBuf(i) = pingRecvBuf(i) END DO CALL MPI_Send(pongSendBuf(lBound:uBound), dataSize, & MPI_INTEGER, pingRank, myThreadID, comm, ierr) END IF END DO END SUBROUTINE multiplePingpong
SUBROUTINE allocateData(sizeofBuffer) integer, intent(in) :: sizeofBuffer allocate(pingSendBuf(sizeofBuffer), pingRecvBuf(sizeofBuffer)) allocate(pongSendBuf(sizeofBuffer), pongRecvBuf(sizeofBuffer)) allocate(finalRecvBuf(sizeofBuffer)) END SUBROUTINE allocateData
SUBROUTINE freeData() deallocate(pingSendBuf, pingRecvBuf) deallocate(pongSendBuf, pongRecvBuf) deallocate(finalRecvBuf) END SUBROUTINE freeData
SUBROUTINE testPingPong(sizeofBuffer, dataSize) integer, intent(in) :: sizeofBuffer, dataSize integer :: i logical :: testFlag IF (myMPIRank == pingRank) THEN testFlag = .true. allocate(testBuf(sizeofBuffer)) DO i = 1,sizeofBuffer testBuf(i) = globalIDarray(myThreadID) END DO DO i = 1, sizeofBuffer IF (testBuf(i) /= finalRecvBuf(i)) THEN testFlag = .false. END IF END DO deallocate(testBuf) END IF CALL MPI_Bcast(testFlag, 1, MPI_LOGICAL, pingRank, comm, ierr) IF (myMPIRank == 0) THEN CALL setTestOutcome(testFlag) END IF END SUBROUTINE testPingPong
        
        
                
                                
        
        