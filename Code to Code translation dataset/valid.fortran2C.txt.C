int openFile(char *fileName){ printf("Attempting to open %s ....",fileName); inputFile = fopen(fileName, "r"); if (inputFile == NULL){ printf("ERROR.\n"); } else{ printf("Success.\n"); } return 0; }
int closeFile(){ fclose(inputFile); return 0; }
int setupBenchmarkList(){ strcpy (benchmarkList[0], "masteronlypingpong"); strcpy (benchmarkList[1], "funnelledpingpong"); strcpy (benchmarkList[2], "multiplepingpong"); strcpy (benchmarkList[3], "masteronlypingping"); strcpy (benchmarkList[4], "funnelledpingping"); strcpy (benchmarkList[5], "multiplepingping"); strcpy (benchmarkList[6], "masteronlyhaloexchange"); strcpy (benchmarkList[7], "funnelledhaloexchange"); strcpy (benchmarkList[8], "multiplehaloexchange"); strcpy (benchmarkList[9], "masteronlymultipingpong"); strcpy (benchmarkList[10], "funnelledmultipingpong"); strcpy (benchmarkList[11], "multiplemultipingpong"); strcpy (benchmarkList[12], "masteronlymultipingping"); strcpy (benchmarkList[13], "funnelledmultipingping"); strcpy (benchmarkList[14], "multiplemultipingping"); strcpy (benchmarkList[15], "barrier"); strcpy (benchmarkList[16], "reduce"); strcpy (benchmarkList[17], "allreduce"); strcpy (benchmarkList[18], "broadcast"); strcpy (benchmarkList[19], "scatter"); strcpy (benchmarkList[20], "gather"); strcpy (benchmarkList[21], "alltoall"); return 0; }
int readBenchmarkParams(){ if (myMPIRank == 0){ printf ("Reading parameters from input file....\n"); fscanf(inputFile, "%d", &minDataSize); fscanf(inputFile, "%d", &maxDataSize); fscanf(inputFile, "%lf", &targetTime); warmUpIters = 2; defaultReps = 1000; printf("------------------------------------------\n"); printf("           Benchmark parameters           \n"); printf("------------------------------------------\n"); printf("Minimum data size %d\n", minDataSize); printf("Maximum data size %d\n", maxDataSize); printf("Target time (sec) %lf\n", targetTime); printf("Default Repetitions %d\n", defaultReps); printf("No. Warmup iterations %d\n", warmUpIters); } the driver is entered the first time */ benchmarkNumber = 0; other MPI processes. */ MPI_Bcast(&minDataSize, 1, MPI_INT, 0, comm); MPI_Bcast(&maxDataSize, 1, MPI_INT, 0, comm); MPI_Bcast(&targetTime, 1, MPI_DOUBLE, 0, comm); MPI_Bcast(&defaultReps, 1, MPI_INT, 0, comm); MPI_Bcast(&warmUpIters, 1, MPI_INT, 0, comm); return 0; }
int findBenchmarkNumber(){ char benchmarkName[MAXSTRING]; int rankInA, rankInB; int i; if (myMPIRank == 0){ check */ benchmarkNumber = ERROR; if (fscanf(inputFile, "%s", benchmarkName) == EOF){ benchmarkNumber = FINISHED; } else { convertToLowercase(benchmarkName); for (i = 0; i< NUM_BENCHMARKS; i++){ if (strcmp(benchmarkName,benchmarkList[i]) == 0){ benchmarkNumber = i; } } } if (benchmarkNumber == ERROR){ printf("ERROR: %s does not match any possible benchmarks\n",benchmarkName); } if (benchmarkNumber <= LASTPPID){ if (fscanf(inputFile, "%d %d",&rankInA, &rankInB) != 2){ printf("ERROR: expecting ranks after %s\n",benchmarkName); } else { PPRanks[0] = findRank(rankInA); PPRanks[1] = findRank(rankInB); } if (PPRanks[0] == PPRanks[1]){ printf("Warning: Ranks are the same; benchmark will not work.\n"); } } } MPI_Bcast(&benchmarkNumber, 1, MPI_INT, 0, comm); if (benchmarkNumber <= LASTPPID) { MPI_Bcast(PPRanks, 2, MPI_INT, 0, comm); } return benchmarkNumber; }
int convertToLowercase(char *convertString){ int i; int len; len = strlen(convertString); for (i=0; i<len; i++){ convertString[i] = tolower(convertString[i]); } return 0; }
int repTimeCheck(double time, int numReps){ int repCheck; if (time < targetTime){ repsToDo = 2 * numReps; repCheck = FALSE; } else if (time > (2 * targetTime)){ repsToDo = max(numReps/2,1); repCheck = TRUE; } else { /* time is >= targetTime */ repCheck = TRUE; } return repCheck; }
int alltoall(){ int dataSizeIter; int bufferSize; repsToDo = defaultReps; dataSizeIter = minDataSize; while (dataSizeIter <= maxDataSize){ bufferSize = dataSizeIter * numThreads * \ numMPIprocs * numThreads; allocateAlltoallData(bufferSize); alltoallKernel(warmUpIters, dataSizeIter); testAlltoall(dataSizeIter); benchComplete = FALSE; while (benchComplete != TRUE){ MPI_Barrier(comm); startTime = MPI_Wtime(); alltoallKernel(repsToDo, dataSizeIter); MPI_Barrier(comm); finishTime = MPI_Wtime(); totalTime = finishTime - startTime; if (myMPIRank==0){ benchComplete = repTimeCheck(totalTime, repsToDo); } MPI_Bcast(&benchComplete, 1, MPI_INT, 0, comm); MPI_Bcast(&repsToDo, 1, MPI_INT, 0, comm); } if (myMPIRank == 0){ setReportParams(dataSizeIter, repsToDo, totalTime); printReport(); } freeAlltoallData(); dataSizeIter = dataSizeIter * 2; } return 0; }
int alltoallKernel(int totalReps, int dataSize){ int repIter, i, j; int dataForEachProc, numsToWrite; int blockNum, startOffset; numsToWrite = numThreads * dataSize; dataForEachProc = numThreads * numThreads * dataSize; for (repIter=0; repIter<totalReps; repIter++){ #pragma omp parallel default(none) \ private(blockNum,i,j) \ shared(numsToWrite,dataForEachProc,globalIDarray) \ shared(alltoallSendBuf,numMPIprocs) { blockNum = (myThreadID)* numsToWrite; for (i=0; i<numMPIprocs; i++){ for (j=0; j<numsToWrite; j++){ alltoallSendBuf[blockNum +(i * dataForEachProc) + j] = \ globalIDarray[myThreadID]; } } } MPI_Alltoall(alltoallSendBuf, dataForEachProc, MPI_INT, \ alltoallRecvBuf, dataForEachProc, MPI_INT, \ comm); #pragma omp parallel default(none) \ private(blockNum,startOffset,i,j) \ shared(alltoallRecvBuf,alltoallFinalBuf,numMPIprocs) \ shared(dataForEachProc,numsToWrite,dataSize,globalIDarray) \ shared(numThreads) { blockNum = myThreadID * dataSize; startOffset = (numsToWrite * numMPIprocs) * myThreadID; for (i=0; i<(numThreads * numMPIprocs); i++){ for (j=0; j<dataSize; j++){ alltoallFinalBuf[startOffset + (i * dataSize) + j] = \ alltoallRecvBuf[blockNum + (i * numsToWrite) + j]; } } } } return 0; }
int allocateAlltoallData(int bufferSize){ alltoallSendBuf = (int *) malloc(bufferSize * sizeof(int)); alltoallRecvBuf = (int *) malloc(bufferSize * sizeof(int)); alltoallFinalBuf = (int *) malloc(bufferSize * sizeof(int)); return 0; }
