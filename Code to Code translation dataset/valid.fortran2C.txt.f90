SUBROUTINE openFile() integer :: argStatus character (len = MAXSTRING) :: fileName CALL GET_COMMAND_ARGUMENT(1,fileName,STATUS=argStatus) IF(argStatus > 0) THEN print *, "ERROR Reading input file from command line." print *, "Usage: mpiexec -np mixedModeBenchmark <fileName>" END IF write(*,fmt="(2x,A,A,A)",advance="no") "Attempting to open '"& ,trim(fileName),"'...." OPEN(UNIT=10, FILE=fileName, STATUS="OLD", & ACTION="READ", FORM="FORMATTED", IOSTAT=ioStatus) IF(ioStatus > 0) THEN write(*,*) "ERROR. IOSTAT =", ioStatus ELSE write(*,*) "Success." END IF END SUBROUTINE openFile
SUBROUTINE closeFile() CLOSE(10) END SUBROUTINE closeFile
SUBROUTINE readBenchmarkParams() IF (myMPIRank == 0) THEN write (*,*) "Reading parameters from input file...." read(10,*) minDataSize read(10,*) maxDataSize read(10,*) targetTime warmUpIters = 2 defaultReps = 1000 write(*,fmt="(A)") "------------------------------------------" write(*,fmt="(A)") "           Benchmark parameters           " write(*,fmt="(A)") "------------------------------------------" write(*,fmt="(A,t25,i10)") "Minimum data size", minDataSize write(*,fmt="(A,t25,i10)") "Maximum data size", maxDataSize write(*,fmt="(A,t25,f10.2)") "Target time (sec)", targetTime write(*,fmt="(A,t25,i10)") "Default Repetitions", defaultReps write(*,fmt="(A,t25,i10)") "No. Warmup iterations", warmUpIters END IF benchmarkNumber = 0 CALL MPI_Bcast(minDataSize, 1, MPI_INTEGER, 0, comm, ierr) CALL MPI_Bcast(maxDataSize, 1, MPI_INTEGER, 0, comm, ierr) CALL MPI_Bcast(targetTime, 1, MPI_DOUBLE_PRECISION, 0, comm, ierr) CALL MPI_Bcast(defaultReps, 1, MPI_INTEGER, 0, comm, ierr) CALL MPI_Bcast(warmUpIters, 1, MPI_INTEGER, 0, comm, ierr) END SUBROUTINE readBenchmarkParams
SUBROUTINE setupBenchmarkList() benchmarkList(1) = "masteronlypingpong" benchmarkList(2) = "funnelledpingpong" benchmarkList(3) = "multiplepingpong" benchmarkList(4) = "masteronlypingping" benchmarkList(5) = "funnelledpingping" benchmarkList(6) = "multiplepingping" benchmarkList(7) = "masteronlyhaloexchange" benchmarkList(8) = "funnelledhaloexchange" benchmarkList(9) = "multiplehaloexchange" benchmarkList(10) = "masteronlymultipingpong" benchmarkList(11) = "funnelledmultipingpong" benchmarkList(12) = "multiplemultipingpong" benchmarkList(13) = "masteronlymultipingping" benchmarkList(14) = "funnelledmultipingping" benchmarkList(15) = "multiplemultipingping" benchmarkList(16) = "barrier" benchmarkList(17) = "reduce" benchmarkList(18) = "allreduce" benchmarkList(19) = "broadcast" benchmarkList(20) = "scatter" benchmarkList(21) = "gather" benchmarkList(22) = "alltoall" END SUBROUTINE setupBenchmarkList
SUBROUTINE findBenchmarkNumber() character (len = MAXSTRING) :: benchmarkName integer :: rankInA, rankInB integer :: i IF (myMPIRank == 0) THEN benchmarkNumber = ERROR READ(10,*,IOSTAT=ioStatus) benchmarkName IF (ioStatus < 0) THEN benchmarkNumber = FINISHED ELSE CALL ConvertTolowercase(benchmarkName) DO i = 1,NUM_BENCHMARKS IF (benchmarkName == benchmarkList(i)) THEN benchmarkNumber = i END IF END DO END IF IF (benchmarkNumber == ERROR) THEN write(*,*) "ERROR: ", trim(benchmarkName) , & " does not match any possible benchmarks" END IF IF (benchmarkNumber <= LASTPPID) THEN READ(10,*,IOSTAT=ioStatus) rankInA, rankInB IF (ioStatus < 0) THEN write(*,*) "ERROR: expecting ranks after ",& trim(benchmarkName) ELSE !if no error find actual MPI ranks PPRanks(1) = findRank(rankInA) PPRanks(2) = findRank(rankInB) END IF IF (PPRanks(1) == PPRanks(2)) THEN write(*,*) "Warning: Ranks are the same; benchmark will",& " not work." END IF END IF END IF CALL MPI_Bcast(benchmarkNumber, 1, MPI_INTEGER, 0, & comm, ierr) IF (benchmarkNumber <= LASTPPID) THEN CALL MPI_Bcast(PPRanks, 2, MPI_INTEGER, 0, comm, ierr) END IF END SUBROUTINE findBenchmarkNumber
SUBROUTINE convertToLowerCase(string) character (len = *), intent(inout) :: string integer :: i, length length = LEN(string) DO i = 1, length IF((string(i:i) >= 'A') .AND. (string(i:i)) <= 'Z') THEN string(i:i) = ACHAR(IACHAR(string(i:i)) + 32) END IF END DO END SUBROUTINE convertToLowerCase
FUNCTION repTimeCheck(time, numReps) DOUBLE PRECISION, intent(in) :: time integer, intent(in) :: numReps logical :: repTimeCheck IF (time < targetTime) THEN repsToDo = 2*numReps repTimeCheck = .false. ELSE IF (time > (2*targetTime)) THEN repsToDo = MAX(numReps/2,1) 
SUBROUTINE alltoall() integer :: dataSizeIter integer :: bufferSize repsToDo = defaultReps dataSizeIter = minDataSize !initialise dataSizeIter DO WHILE (dataSizeIter <= maxDataSize) bufferSize = dataSizeIter * (numThreads * numMPIprocs) & * numThreads CALL allocateData(bufferSize) CALL alltoallKernel(warmUpIters,dataSizeIter) CALL testAlltoall(dataSizeIter) benchComplete = .false. DO WHILE (benchComplete .NEQV. .true.) CALL MPI_Barrier(comm, ierr) startTime = MPI_Wtime() CALL alltoallKernel(repsToDo, dataSizeIter) CALL MPI_Barrier(comm, ierr) finishTime = MPI_Wtime() totalTime = finishTime - startTime if (myMPIRank==0) then benchComplete = repTimeCheck(totalTime, repsToDo) end if call MPI_Bcast(benchComplete, 1, MPI_INTEGER, 0, comm, ierr) call MPI_Bcast(repsToDo, 1, MPI_INTEGER, 0, comm, ierr) END DO IF (myMPIRank == 0) THEN CALL setReportParams(dataSizeIter,repsToDo,totalTime) CALL printReport() END IF CALL freeData() dataSizeIter = dataSizeIter * 2 END DO !End loop over data sizes END SUBROUTINE alltoall
SUBROUTINE alltoallKernel(totalReps,dataSize) integer, intent(in) :: totalReps, dataSize integer :: repIter, i, j integer :: dataForEachProc, numsToWrite integer :: blockNum, startOffset numsToWrite = numThreads * dataSize dataForEachProc = numThreads * numThreads * dataSize DO repIter = 1, totalReps blockNum = (myThreadID - 1)*numsToWrite DO i = 1, numMPIprocs !loop over MPI processes DO j = 1, numsToWrite !loop over data to write alltoallSendBuf(blockNum + ((i-1)*dataForEachProc + j)) = & globalIDarray(myThreadID) END DO END DO CALL MPI_Alltoall(alltoallSendBuf, dataForEachProc, MPI_INTEGER, & alltoallRecvBuf, dataForEachProc, MPI_INTEGER, & comm, ierr) blockNum = (myThreadID-1)*dataSize startOffset = (numsToWrite * numMPIprocs) startOffset = startOffset * (myThreadID -1) DO i = 1, (numThreads*numMPIprocs) DO j = 1, dataSize alltoallFinalBuf(startOffset + ((i-1)*dataSize) + j ) = & alltoallRecvBuf(blockNum + ((i-1)*numsToWrite) + j) END DO END DO END DO !End loop over repetitions END SUBROUTINE alltoallKernel
SUBROUTINE allocateData(bufferSize) integer, intent(in) :: bufferSize allocate(alltoallSendBuf(bufferSize)) allocate(alltoallRecvBuf(bufferSize)) allocate(alltoallFinalBuf(bufferSize)) END SUBROUTINE allocateData

        
                
                                
        
        