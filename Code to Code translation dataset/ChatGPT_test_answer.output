<<<<<<< HEAD
void funnelledPingping(int totalReps, int dataSize) { int repIter, i, destRank; int sizeofBuffer = dataSize; MPI_Request requestID; MPI_Status status; int tag = 0; if (myMPIRank == pingRankA) { destRank = pingRankB; } else if (myMPIRank == pingRankB) { destRank = pingRankA; } for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRankA || myMPIRank == pingRankB) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Isend(pingSendBuf, sizeofBuffer, MPI_INT, destRank, tag, comm, &requestID); MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INT, destRank, tag, comm, &status); MPI_Wait(&requestID, &status); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pingRecvBuf[i]; } } } }
void multiplePingping(int totalReps, int dataSize) { int repIter, i; int destRank; int lBound, uBound; if (myMPIRank == pingRankA) { destRank = pingRankB; } else if (myMPIRank == pingRankB) { destRank = pingRankA; } for (repIter = 0; repIter < totalReps; repIter++) { if (myMPIRank == pingRankA || myMPIRank == pingRankB) { lBound = ((myThreadID - 1) * dataSize) + 1; uBound = (myThreadID * dataSize); for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Isend(pingSendBuf + lBound, dataSize, MPI_INTEGER, destRank, myThreadID, comm, &requestID); MPI_Recv(pingRecvBuf + lBound, dataSize, MPI_INTEGER, destRank, myThreadID, comm, &status); MPI_Wait(&requestID, &status); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pingRecvBuf[i]; } } } }
void allocateData(int bufferSize) { pingSendBuf = (int *)malloc(bufferSize * sizeof(int)); pingRecvBuf = (int *)malloc(bufferSize * sizeof(int)); finalRecvBuf = (int *)malloc(bufferSize * sizeof(int)); }
void freeData() { free(pingSendBuf); free(pingRecvBuf); free(finalRecvBuf); }
int sizeofBuffer, dataSize; int otherPingRank, i; int testFlag, reduceFlag; testFlag = true; if (myMPIRank == pingRankA || myMPIRank == pingRankB) { testBuf = (int*)malloc(sizeof(int) * sizeofBuffer); if (myMPIRank == pingRankA) { otherPingRank = pingRankB; } else if (myMPIRank == pingRankB) { otherPingRank = pingRankA; } for (i = 0; i < sizeofBuffer; i++) { testBuf[i] = (otherPingRank * numThreads) + myThreadID; } for (i = 0; i < sizeofBuffer; i++) { if (testBuf[i] != finalRecvBuf[i]) { testFlag = false; } } free(testBuf); } MPI_Reduce(&testFlag, &reduceFlag, 1, MPI_LOGICAL, MPI_LAND, 0, comm, &ierr); if (myMPIRank == 0) { setTestOutcome(reduceFlag); }
int benchmarkType; int dataSizeIter; int sameNode; pingRank = PPRanks[0]; pongRank = PPRanks[1]; sameNode = compareProcNames(pingRank,pongRank); if (myMPIRank == 0) { printNodeReport(sameNode,pingRank,pongRank); printBenchHeader(); } repsToDo = defaultReps; dataSizeIter = minDataSize; while (dataSizeIter <= maxDataSize) { sizeofBuffer = dataSizeIter * numThreads; allocateData(sizeofBuffer); if (benchmarkType == MASTERONLY) { masteronlyPingpong(warmUpIters, dataSizeIter); } else if (benchmarkType == FUNNELLED) { funnelledPingpong(warmUpIters, dataSizeIter); } else if (benchmarkType == MULTIPLE) { multiplePingpong(warmUpIters, dataSizeIter); } testPingpong(sizeofBuffer, dataSizeIter); benchComplete = false; while (benchComplete != true) { MPI_Barrier(comm, &ierr); startTime = MPI_Wtime(); if (benchmarkType == MASTERONLY) { masteronlyPingpong(repsToDo, dataSizeIter); } else if (benchmarkType == FUNNELLED) { funnelledPingpong(repsToDo, dataSizeIter); }
void masteronlyPingpong(int totalReps, int dataSize) { int repIter, i; for (repIter = 0; repIter < totalReps; repIter++) { if (myMPIRank == pingRank) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf, sizeofBuffer, MPI_INTEGER, pongRank, tag, comm, &ierr); MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INTEGER, pongRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INTEGER, pingRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf, sizeofBuffer, MPI_INTEGER, pingRank, tag, comm, &ierr); } } }
void funnelledPingpong(int totalReps, int dataSize) { int repIter, i; for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRank) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf, sizeofBuffer, MPI_INT, pongRank, tag, comm, &ierr); MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INT, pongRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INT, pingRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf, sizeofBuffer, MPI_INT, pingRank, tag, comm, &ierr); } } }
void multiplePingpong(int totalReps, int dataSize) { int repIter, i; int lBound, uBound; for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRank) { lBound = ((myThreadID-1)* dataSize) + 1; uBound = (myThreadID * dataSize); for (i = 1; i <= sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf + lBound, dataSize, MPI_INT, pongRank, myThreadID, comm, &ierr); MPI_Recv(pongRecvBuf + lBound, dataSize, MPI_INT, pongRank, myThreadID, comm, &status, &ierr); for (i = 1; i <= sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { lBound = ((myThreadID-1)* dataSize) + 1; uBound = (myThreadID * dataSize); MPI_Recv(pingRecvBuf + lBound, dataSize, MPI_INT, pingRank, myThreadID, comm, &status, &ierr); for (i = 1; i <= sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf + lBound, dataSize, MPI_INT, pingRank, myThreadID, comm, &ierr); } } }
void allocateData(int sizeofBuffer) { int pingSendBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pingRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pongSendBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pongRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); int finalRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); }
void freeData() { free(pingSendBuf); free(pingRecvBuf); free(pongSendBuf); free(pongRecvBuf); free(finalRecvBuf); }
void testPingPong(int sizeofBuffer, int dataSize) { int i; int testFlag = 0; if (myMPIRank == pingRank) { int testBuf[sizeofBuffer]; for (i = 0; i < sizeofBuffer; i++) { testBuf[i] = globalIDarray[myThreadID]; } for (i = 0; i < sizeofBuffer; i++) { if (testBuf[i] != finalRecvBuf[i]) { testFlag = 1; break; } } } MPI_Bcast(&testFlag, 1, MPI_LOGICAL, pingRank, comm, &ierr); if (myMPIRank == 0) { setTestOutcome(testFlag); } }


=======
void funnelledPingping(int totalReps, int dataSize) { int repIter, i, destRank; int sizeofBuffer = dataSize; MPI_Request requestID; MPI_Status status; int tag = 0; if (myMPIRank == pingRankA) { destRank = pingRankB; } else if (myMPIRank == pingRankB) { destRank = pingRankA; } for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRankA || myMPIRank == pingRankB) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Isend(pingSendBuf, sizeofBuffer, MPI_INT, destRank, tag, comm, &requestID); MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INT, destRank, tag, comm, &status); MPI_Wait(&requestID, &status); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pingRecvBuf[i]; } } } }
void multiplePingping(int totalReps, int dataSize) { int repIter, i; int destRank; int lBound, uBound; if (myMPIRank == pingRankA) { destRank = pingRankB; } else if (myMPIRank == pingRankB) { destRank = pingRankA; } for (repIter = 0; repIter < totalReps; repIter++) { if (myMPIRank == pingRankA || myMPIRank == pingRankB) { lBound = ((myThreadID - 1) * dataSize) + 1; uBound = (myThreadID * dataSize); for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Isend(pingSendBuf + lBound, dataSize, MPI_INTEGER, destRank, myThreadID, comm, &requestID); MPI_Recv(pingRecvBuf + lBound, dataSize, MPI_INTEGER, destRank, myThreadID, comm, &status); MPI_Wait(&requestID, &status); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pingRecvBuf[i]; } } } }
void allocateData(int bufferSize) { pingSendBuf = (int *)malloc(bufferSize * sizeof(int)); pingRecvBuf = (int *)malloc(bufferSize * sizeof(int)); finalRecvBuf = (int *)malloc(bufferSize * sizeof(int)); }
void freeData() { free(pingSendBuf); free(pingRecvBuf); free(finalRecvBuf); }
int sizeofBuffer, dataSize; int otherPingRank, i; int testFlag, reduceFlag; testFlag = true; if (myMPIRank == pingRankA || myMPIRank == pingRankB) { testBuf = (int*)malloc(sizeof(int) * sizeofBuffer); if (myMPIRank == pingRankA) { otherPingRank = pingRankB; } else if (myMPIRank == pingRankB) { otherPingRank = pingRankA; } for (i = 0; i < sizeofBuffer; i++) { testBuf[i] = (otherPingRank * numThreads) + myThreadID; } for (i = 0; i < sizeofBuffer; i++) { if (testBuf[i] != finalRecvBuf[i]) { testFlag = false; } } free(testBuf); } MPI_Reduce(&testFlag, &reduceFlag, 1, MPI_LOGICAL, MPI_LAND, 0, comm, &ierr); if (myMPIRank == 0) { setTestOutcome(reduceFlag); }
int benchmarkType; int dataSizeIter; int sameNode; pingRank = PPRanks[0]; pongRank = PPRanks[1]; sameNode = compareProcNames(pingRank,pongRank); if (myMPIRank == 0) { printNodeReport(sameNode,pingRank,pongRank); printBenchHeader(); } repsToDo = defaultReps; dataSizeIter = minDataSize; while (dataSizeIter <= maxDataSize) { sizeofBuffer = dataSizeIter * numThreads; allocateData(sizeofBuffer); if (benchmarkType == MASTERONLY) { masteronlyPingpong(warmUpIters, dataSizeIter); } else if (benchmarkType == FUNNELLED) { funnelledPingpong(warmUpIters, dataSizeIter); } else if (benchmarkType == MULTIPLE) { multiplePingpong(warmUpIters, dataSizeIter); } testPingpong(sizeofBuffer, dataSizeIter); benchComplete = false; while (benchComplete != true) { MPI_Barrier(comm, &ierr); startTime = MPI_Wtime(); if (benchmarkType == MASTERONLY) { masteronlyPingpong(repsToDo, dataSizeIter); } else if (benchmarkType == FUNNELLED) { funnelledPingpong(repsToDo, dataSizeIter); }
void masteronlyPingpong(int totalReps, int dataSize) { int repIter, i; for (repIter = 0; repIter < totalReps; repIter++) { if (myMPIRank == pingRank) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf, sizeofBuffer, MPI_INTEGER, pongRank, tag, comm, &ierr); MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INTEGER, pongRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INTEGER, pingRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf, sizeofBuffer, MPI_INTEGER, pingRank, tag, comm, &ierr); } } }
void funnelledPingpong(int totalReps, int dataSize) { int repIter, i; for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRank) { for (i = 0; i < sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf, sizeofBuffer, MPI_INT, pongRank, tag, comm, &ierr); MPI_Recv(pongRecvBuf, sizeofBuffer, MPI_INT, pongRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { MPI_Recv(pingRecvBuf, sizeofBuffer, MPI_INT, pingRank, tag, comm, &status, &ierr); for (i = 0; i < sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf, sizeofBuffer, MPI_INT, pingRank, tag, comm, &ierr); } } }
void multiplePingpong(int totalReps, int dataSize) { int repIter, i; int lBound, uBound; for (repIter = 1; repIter <= totalReps; repIter++) { if (myMPIRank == pingRank) { lBound = ((myThreadID-1)* dataSize) + 1; uBound = (myThreadID * dataSize); for (i = 1; i <= sizeofBuffer; i++) { pingSendBuf[i] = globalIDarray[myThreadID]; } MPI_Send(pingSendBuf + lBound, dataSize, MPI_INT, pongRank, myThreadID, comm, &ierr); MPI_Recv(pongRecvBuf + lBound, dataSize, MPI_INT, pongRank, myThreadID, comm, &status, &ierr); for (i = 1; i <= sizeofBuffer; i++) { finalRecvBuf[i] = pongRecvBuf[i]; } } else if (myMPIRank == pongRank) { lBound = ((myThreadID-1)* dataSize) + 1; uBound = (myThreadID * dataSize); MPI_Recv(pingRecvBuf + lBound, dataSize, MPI_INT, pingRank, myThreadID, comm, &status, &ierr); for (i = 1; i <= sizeofBuffer; i++) { pongSendBuf[i] = pingRecvBuf[i]; } MPI_Send(pongSendBuf + lBound, dataSize, MPI_INT, pingRank, myThreadID, comm, &ierr); } } }
void allocateData(int sizeofBuffer) { int pingSendBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pingRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pongSendBuf = (int)malloc(sizeof(int)*sizeofBuffer); int pongRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); int finalRecvBuf = (int)malloc(sizeof(int)*sizeofBuffer); }
void freeData() { free(pingSendBuf); free(pingRecvBuf); free(pongSendBuf); free(pongRecvBuf); free(finalRecvBuf); }
void testPingPong(int sizeofBuffer, int dataSize) { int i; int testFlag = 0; if (myMPIRank == pingRank) { int testBuf[sizeofBuffer]; for (i = 0; i < sizeofBuffer; i++) { testBuf[i] = globalIDarray[myThreadID]; } for (i = 0; i < sizeofBuffer; i++) { if (testBuf[i] != finalRecvBuf[i]) { testFlag = 1; break; } } } MPI_Bcast(&testFlag, 1, MPI_LOGICAL, pingRank, comm, &ierr); if (myMPIRank == 0) { setTestOutcome(testFlag); } }


>>>>>>> 5bf531c25e66e87cb0397f188fb466fc2d8e800e
