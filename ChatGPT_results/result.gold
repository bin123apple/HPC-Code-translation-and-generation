program ft use ft_data use ft_fields use mpinpb implicit none integer i, ierr integer iter double precision total_time, mflops logical verified character class call setup(class) if (.not. active) goto 999 do i = 1, t_max call timer_clear(i) end do call timer_start(T_init) call compute_indexmap(twiddle, dims(1,3), dims(2,3), dims(3,3)) call compute_initial_conditions(u1, dims(1,1), dims(2,1),  & &                                dims(3,1)) call fft_init (dims(1,1)) call fft(1, u1, u0) call timer_stop(T_init) if (me .eq. 0) then write(*, 1000) timer_read(T_init) 1000     format(/' Initialization time =', f12.4/) endif do i = 1, t_max call timer_clear(i) end do call MPI_Barrier(comm_solve, ierr) call timer_start(T_total) if (timers_enabled) call timer_start(T_setup) call compute_indexmap(twiddle, dims(1,3), dims(2,3), dims(3,3)) call compute_initial_conditions(u1, dims(1,1), dims(2,1),  & &                                dims(3,1)) call fft_init (dims(1,1)) !      if (timers_enabled) call synchup() if (timers_enabled) call timer_stop(T_setup) if (timers_enabled) call timer_start(T_fft) call fft(1, u1, u0) if (timers_enabled) call timer_stop(T_fft) do iter = 1, niter if (timers_enabled) call timer_start(T_evolve) call evolve(u0, u1, twiddle,  & &               dims(1,1), dims(2,1), dims(3,1)) if (timers_enabled) call timer_stop(T_evolve) if (timers_enabled) call timer_start(T_fft) call fft(-1, u1, u2) if (timers_enabled) call timer_stop(T_fft) !         if (timers_enabled) call synchup() if (timers_enabled) call timer_start(T_checksum) call checksum(iter, u2, dims(1,1), dims(2,1), dims(3,1)) if (timers_enabled) call timer_stop(T_checksum) end do call verify(niter, verified, class) call timer_stop(t_total) !!      if (np .ne. np_min) verified = .false. total_time = timer_read(t_total) if( total_time .ne. 0. ) then mflops = 1.0d-6*ntotal_f *  & &             (14.8157+7.19641*log(ntotal_f)  & &          +  (5.23518+7.21113*log(ntotal_f))*niter)  & &                 /total_time else mflops = 0.0 endif if (me .eq. 0) then call print_results('FT', class, nx, ny, nz, niter, np_min, np,  & &     total_time, mflops, '          floating point', verified,  & &     npbversion, compiletime, cs1, cs2, cs3, cs4, cs5, cs6, cs7) endif if (timers_enabled) call print_timers() 999 continue call MPI_Finalize(ierr) end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine evolve(u0, u1, twiddle, d1, d2, d3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! evolve u0 -> u1 (t time steps) in fourier space !--------------------------------------------------------------------- use ft_data implicit none integer d1, d2, d3 double precision exi double complex u0(d1,d2,d3) double complex u1(d1,d2,d3) double precision twiddle(d1,d2,d3) integer i, j, k do k = 1, d3 do j = 1, d2 do i = 1, d1 u0(i,j,k) = u0(i,j,k)*(twiddle(i,j,k)) u1(i,j,k) = u0(i,j,k) end do end do end do return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine compute_initial_conditions(u0, d1, d2, d3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! Fill in array u0 with initial conditions from ! random number generator !--------------------------------------------------------------------- use ft_data implicit none integer d1, d2, d3 double complex u0(d1, d2, d3) integer k double precision x0, start, an, dummy !--------------------------------------------------------------------- ! 0-D and 1-D layouts are easy because each processor gets a contiguous ! chunk of the array, in the Fortran ordering sense. ! For a 2-D layout, it's a bit more complicated. We always ! have entire x-lines (contiguous) in processor. ! We can do ny/np1 of them at a time since we have ! ny/np1 contiguous in y-direction. But then we jump ! by z-planes (nz/np2 of them, total). ! For the 0-D and 1-D layouts we could do larger chunks, but ! this turns out to have no measurable impact on performance. !--------------------------------------------------------------------- start = seed !--------------------------------------------------------------------- ! Jump to the starting element for our first plane. !--------------------------------------------------------------------- call ipow46(a, 2*nx, (zstart(1)-1)*ny + (ystart(1)-1), an) dummy = randlc(start, an) call ipow46(a, 2*nx, ny, an) !--------------------------------------------------------------------- ! Go through by z planes filling in one square at a time. !--------------------------------------------------------------------- do k = 1, dims(3, 1) ! nz/np2 x0 = start call vranlc(2*nx*dims(2, 1), x0, a, u0(1, 1, k)) if (k .ne. dims(3, 1)) dummy = randlc(start, an) end do return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine ipow46(a, exp_1, exp_2, result) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! compute a^exponent mod 2^46 !--------------------------------------------------------------------- implicit none double precision a, result, dummy, q, r integer exp_1, exp_2, n, n2, ierr external randlc double precision randlc logical  two_pow !--------------------------------------------------------------------- ! Use !   a^n = a^(n/2)*a^(n/2) if n even else !   a^n = a*a^(n-1)       if n odd !--------------------------------------------------------------------- result = 1 if (exp_2 .eq. 0 .or. exp_1 .eq. 0) return q = a r = 1 n = exp_1 two_pow = .true. do while (two_pow) n2 = n/2 if (n2 * 2 .eq. n) then dummy = randlc(q, q) n = n2 else n = n * exp_2 two_pow = .false. endif end do do while (n .gt. 1) n2 = n/2 if (n2 * 2 .eq. n) then dummy = randlc(q, q) n = n2 else dummy = randlc(r, q) n = n-1 endif end do dummy = randlc(r, q) result = r return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine setup(class) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data use mpinpb implicit none character class integer ierr, i, fstatus debug = .FALSE. call MPI_Init(ierr) !--------------------------------------------------------------------- !     get a process grid that requires a pwr-2 number of procs. !     excess ranks are marked as inactive. !--------------------------------------------------------------------- call get_active_nprocs(3, np1, np2, np_min,  & &                       np, me, comm_solve, active) if (.not. active) return if (.not. convertdouble) then dc_type = MPI_DOUBLE_COMPLEX else dc_type = MPI_COMPLEX endif if (me .eq. 0) then write(*, 1000) call check_timer_flag( timers_enabled ) open (unit=2,file='inputft.data',status='old', iostat=fstatus) if (fstatus .eq. 0) then write(*,233) 233        format(' Reading from input file inputft.data') read (2,*) niter read (2,*) layout_type read (2,*) np1, np2 close(2) !--------------------------------------------------------------------- ! check to make sure input data is consistent !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! 1. product of processor grid dims must equal number of processors !--------------------------------------------------------------------- if (np1 * np2 .ne. np_min) then write(*, 238) 238           format(' np1 and np2 given in input file are not valid.') write(*, 239) np1*np2, np_min 239           format(' Product is ', i5, ' and should be ', i5) call MPI_Abort(MPI_COMM_WORLD, 1, ierr) endif !--------------------------------------------------------------------- ! 2. layout type must be valid !--------------------------------------------------------------------- if (layout_type .ne. layout_0D .and.  & &          layout_type .ne. layout_1D .and.  & &          layout_type .ne. layout_2D) then write(*, 240) 240           format(' Layout type specified in inputft.data is  & &                  invalid ') call MPI_Abort(MPI_COMM_WORLD, 1, ierr) endif !--------------------------------------------------------------------- ! 3. 0D layout must be 1x1 grid !--------------------------------------------------------------------- if (layout_type .eq. layout_0D .and.  & &            (np1 .ne.1 .or. np2 .ne. 1)) then write(*, 241) 241           format(' For 0D layout, both np1 and np2 must be 1 ') call MPI_Abort(MPI_COMM_WORLD, 1, ierr) endif !--------------------------------------------------------------------- ! 4. 1D layout must be 1xN grid !--------------------------------------------------------------------- if (layout_type .eq. layout_1D .and. np1 .ne. 1) then write(*, 242) 242           format(' For 1D layout, np1 must be 1 ') call MPI_Abort(MPI_COMM_WORLD, 1, ierr) endif else write(*,234) niter = niter_default if (np_min .eq. 1) then np1 = 1 np2 = 1 layout_type = layout_0D else if (np_min .le. nz) then np1 = 1 np2 = np_min layout_type = layout_1D else np1 = nz np2 = np_min/nz layout_type = layout_2D endif endif call set_class(nx, ny, nz, niter, class) 234     format(' No input file inputft.data. Using compiled defaults') write(*, 1001) nx, ny, nz, class write(*, 1002) niter write(*, 1004) np if (np .ne. np_min) write(*, 1006) np_min write(*, 1005) np1, np2 if (layout_type .eq. layout_0D) then write(*, 1010) '0D' else if (layout_type .eq. layout_1D) then write(*, 1010) '1D' else write(*, 1010) '2D' endif 1000 format(//,' NAS Parallel Benchmarks 3.4 -- FT Benchmark',/) 1001    format(' Size                : ', i4, 'x', i4, 'x', i4,  & &          '  (class ', a, ')') 1002    format(' Iterations          : ', 7x, i7) 1004    format(' Number of processes : ', 7x, i7) 1005    format(' Processor array     : ', 5x, i4, 'x', i4) 1006    format(' WARNING: Number of processes is not power of two (',  & &          i0, ' active)') 1010    format(' Layout type         : ', 9x, A5) endif !--------------------------------------------------------------------- ! Broadcast parameters !--------------------------------------------------------------------- call MPI_BCAST(np1, 1, MPI_INTEGER, 0, comm_solve, ierr) call MPI_BCAST(np2, 1, MPI_INTEGER, 0, comm_solve, ierr) call MPI_BCAST(layout_type, 1, MPI_INTEGER, 0, comm_solve,  & &               ierr) call MPI_BCAST(niter, 1, MPI_INTEGER, 0, comm_solve, ierr) call MPI_BCAST(timers_enabled, 1, MPI_LOGICAL, 0, comm_solve,  & &               ierr) if (np1 .eq. 1 .and. np2 .eq. 1) then layout_type = layout_0D else if (np1 .eq. 1) then layout_type = layout_1D else layout_type = layout_2D endif if (layout_type .eq. layout_0D) then do i = 1, 3 dims(1, i) = nx dims(2, i) = ny dims(3, i) = nz end do else if (layout_type .eq. layout_1D) then dims(1, 1) = nx dims(2, 1) = ny dims(3, 1) = nz dims(1, 2) = nx dims(2, 2) = ny dims(3, 2) = nz dims(1, 3) = nz dims(2, 3) = nx dims(3, 3) = ny else if (layout_type .eq. layout_2D) then dims(1, 1) = nx dims(2, 1) = ny dims(3, 1) = nz dims(1, 2) = ny dims(2, 2) = nx dims(3, 2) = nz dims(1, 3) = nz dims(2, 3) = nx dims(3, 3) = ny endif do i = 1, 3 dims(2, i) = dims(2, i) / np1 dims(3, i) = dims(3, i) / np2 end do !--------------------------------------------------------------------- ! Allocate space !--------------------------------------------------------------------- call alloc_space !--------------------------------------------------------------------- ! Determine processor coordinates of this processor ! Processor grid is np1xnp2. ! Arrays are always (n1, n2/np1, n3/np2) ! Processor coords are zero-based. !--------------------------------------------------------------------- me2 = mod(me, np2)  ! goes from 0...np2-1 me1 = me/np2        ! goes from 0...np1-1 !--------------------------------------------------------------------- ! Communicators for rows/columns of processor grid. ! commslice1 is communicator of all procs with same me1, ranked as me2 ! commslice2 is communicator of all procs with same me2, ranked as me1 ! mpi_comm_split(comm, color, key, ...) !--------------------------------------------------------------------- call MPI_Comm_split(comm_solve, me1, me2, commslice1, ierr) call MPI_Comm_split(comm_solve, me2, me1, commslice2, ierr) !      if (timers_enabled) call synchup() if (debug) print *, 'proc coords: ', me, me1, me2 !--------------------------------------------------------------------- ! Determine which section of the grid is owned by this ! processor. !--------------------------------------------------------------------- if (layout_type .eq. layout_0d) then do i = 1, 3 xstart(i) = 1 xend(i)   = nx ystart(i) = 1 yend(i)   = ny zstart(i) = 1 zend(i)   = nz end do else if (layout_type .eq. layout_1d) then xstart(1) = 1 xend(1)   = nx ystart(1) = 1 yend(1)   = ny zstart(1) = 1 + me2 * nz/np2 zend(1)   = (me2+1) * nz/np2 xstart(2) = 1 xend(2)   = nx ystart(2) = 1 yend(2)   = ny zstart(2) = 1 + me2 * nz/np2 zend(2)   = (me2+1) * nz/np2 xstart(3) = 1 xend(3)   = nx ystart(3) = 1 + me2 * ny/np2 yend(3)   = (me2+1) * ny/np2 zstart(3) = 1 zend(3)   = nz else if (layout_type .eq. layout_2d) then xstart(1) = 1 xend(1)   = nx ystart(1) = 1 + me1 * ny/np1 yend(1)   = (me1+1) * ny/np1 zstart(1) = 1 + me2 * nz/np2 zend(1)   = (me2+1) * nz/np2 xstart(2) = 1 + me1 * nx/np1 xend(2)   = (me1+1)*nx/np1 ystart(2) = 1 yend(2)   = ny zstart(2) = zstart(1) zend(2)   = zend(1) xstart(3) = xstart(2) xend(3)   = xend(2) ystart(3) = 1 + me2 *ny/np2 yend(3)   = (me2+1)*ny/np2 zstart(3) = 1 zend(3)   = nz endif fftblock = fftblock_default fftblockpad = fftblockpad_default if (layout_type .eq. layout_2d) then if (dims(2, 1) .lt. fftblock) fftblock = dims(2, 1) if (dims(2, 2) .lt. fftblock) fftblock = dims(2, 2) if (dims(2, 3) .lt. fftblock) fftblock = dims(2, 3) endif if (fftblock .ne. fftblock_default) fftblockpad = fftblock+3 return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine compute_indexmap(twiddle, d1, d2, d3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! compute function from local (i,j,k) to ibar^2+jbar^2+kbar^2 ! for time evolution exponent. !--------------------------------------------------------------------- use ft_data use mpinpb implicit none integer d1, d2, d3 integer i, j, k, ii, ii2, jj, ij2, kk double precision ap, twiddle(d1, d2, d3) !--------------------------------------------------------------------- ! this function is very different depending on whether ! we are in the 0d, 1d or 2d layout. Compute separately. ! basically we want to convert the fortran indices !   1 2 3 4 5 6 7 8 ! to !   0 1 2 3 -4 -3 -2 -1 ! The following magic formula does the trick: ! mod(i-1+n/2, n) - n/2 !--------------------------------------------------------------------- ap = - 4.d0 * alpha * pi *pi if (layout_type .eq. layout_0d) then ! xyz layout do i = 1, dims(1,3) ii =  mod(i+xstart(3)-2+nx/2, nx) - nx/2 ii2 = ii*ii do j = 1, dims(2,3) jj = mod(j+ystart(3)-2+ny/2, ny) - ny/2 ij2 = jj*jj+ii2 do k = 1, dims(3,3) kk = mod(k+zstart(3)-2+nz/2, nz) - nz/2 twiddle(i,j,k) = dexp(ap*dfloat(kk*kk+ij2)) end do end do end do else if (layout_type .eq. layout_1d) then ! zxy layout do i = 1,dims(2,3) ii =  mod(i+xstart(3)-2+nx/2, nx) - nx/2 ii2 = ii*ii do j = 1,dims(3,3) jj = mod(j+ystart(3)-2+ny/2, ny) - ny/2 ij2 = jj*jj+ii2 do k = 1,dims(1,3) kk = mod(k+zstart(3)-2+nz/2, nz) - nz/2 twiddle(k,i,j) = dexp(ap*dfloat(kk*kk+ij2)) end do end do end do else if (layout_type .eq. layout_2d) then ! zxy layout do i = 1,dims(2,3) ii =  mod(i+xstart(3)-2+nx/2, nx) - nx/2 ii2 = ii*ii do j = 1, dims(3,3) jj = mod(j+ystart(3)-2+ny/2, ny) - ny/2 ij2 = jj*jj+ii2 do k =1,dims(1,3) kk = mod(k+zstart(3)-2+nz/2, nz) - nz/2 twiddle(k,i,j) = dexp(ap*dfloat(kk*kk+ij2)) end do end do end do else print *, ' Unknown layout type ', layout_type stop endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine print_timers() !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data use mpinpb implicit none integer i, ierr character*25 tstrings(T_max+2) double precision t1(T_max+2), tsum(T_max+2),  & &                 tming(T_max+2), tmaxg(T_max+2) data tstrings / '          total ',  & &                '          setup ',  & &                '            fft ',  & &                '         evolve ',  & &                '       checksum ',  & &                '         fftlow ',  & &                '        fftcopy ',  & &                '      transpose ',  & &                ' transpose1_loc ',  & &                ' transpose1_glo ',  & &                ' transpose1_fin ',  & &                ' transpose2_loc ',  & &                ' transpose2_glo ',  & &                ' transpose2_fin ',  & &                '           sync ',  & &                '           init ',  & &                '        totcomp ',  & &                '        totcomm ' / do i = 1, t_max t1(i) = timer_read(i) end do t1(t_max+2) = t1(t_transxzglo) + t1(t_transxyglo) + t1(t_synch) t1(t_max+1) = t1(t_total) - t1(t_max+2) call MPI_Reduce(t1, tsum,  t_max+2, MPI_DOUBLE_PRECISION,  & &                MPI_SUM, 0, comm_solve, ierr) call MPI_Reduce(t1, tming, t_max+2, MPI_DOUBLE_PRECISION,  & &                MPI_MIN, 0, comm_solve, ierr) call MPI_Reduce(t1, tmaxg, t_max+2, MPI_DOUBLE_PRECISION,  & &                MPI_MAX, 0, comm_solve, ierr) if (me .ne. 0) return write(*, 800) np_min do i = 1, t_max+2 if (tsum(i) .ne. 0.0d0) then write(*, 810) i, tstrings(i), tming(i), tmaxg(i),  & &                    tsum(i)/np_min endif end do 800  format(' nprocs =', i6, 19x, 'minimum', 5x, 'maximum',  & &       5x, 'average') 810  format(' timer ', i2, '(', A16, ') :', 3(2X,F10.4)) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine fft(dir, x1, x2) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer dir double complex x1(ntdivnp), x2(ntdivnp) double complex scratch(fftblockpad_default*maxdim*2) !--------------------------------------------------------------------- ! note: args x1, x2 must be different arrays ! note: args for cfftsx are (direction, layout, xin, xout, scratch) !       xin/xout may be the same and it can be somewhat faster !       if they are ! note: args for transpose are (layout1, layout2, xin, xout) !       xin/xout must be different !--------------------------------------------------------------------- if (dir .eq. 1) then if (layout_type .eq. layout_0d) then call cffts1(1, dims(1,1), dims(2,1), dims(3,1),  & &                  x1, x1, scratch) call cffts2(1, dims(1,2), dims(2,2), dims(3,2),  & &                  x1, x1, scratch) call cffts3(1, dims(1,3), dims(2,3), dims(3,3),  & &                  x1, x2, scratch) else if (layout_type .eq. layout_1d) then call cffts1(1, dims(1,1), dims(2,1), dims(3,1),  & &                  x1, x1, scratch) call cffts2(1, dims(1,2), dims(2,2), dims(3,2),  & &                  x1, x1, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_xy_z(2, 3, x1, x2) if (timers_enabled) call timer_stop(T_transpose) call cffts1(1, dims(1,3), dims(2,3), dims(3,3),  & &                  x2, x2, scratch) else if (layout_type .eq. layout_2d) then call cffts1(1, dims(1,1), dims(2,1), dims(3,1),  & &                  x1, x1, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_x_y(1, 2, x1, x2) if (timers_enabled) call timer_stop(T_transpose) call cffts1(1, dims(1,2), dims(2,2), dims(3,2),  & &                  x2, x2, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_x_z(2, 3, x2, x1) if (timers_enabled) call timer_stop(T_transpose) call cffts1(1, dims(1,3), dims(2,3), dims(3,3),  & &                  x1, x2, scratch) endif else if (layout_type .eq. layout_0d) then call cffts3(-1, dims(1,3), dims(2,3), dims(3,3),  & &                  x1, x1, scratch) call cffts2(-1, dims(1,2), dims(2,2), dims(3,2),  & &                  x1, x1, scratch) call cffts1(-1, dims(1,1), dims(2,1), dims(3,1),  & &                  x1, x2, scratch) else if (layout_type .eq. layout_1d) then call cffts1(-1, dims(1,3), dims(2,3), dims(3,3),  & &                  x1, x1, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_x_yz(3, 2, x1, x2) if (timers_enabled) call timer_stop(T_transpose) call cffts2(-1, dims(1,2), dims(2,2), dims(3,2),  & &                  x2, x2, scratch) call cffts1(-1, dims(1,1), dims(2,1), dims(3,1),  & &                  x2, x2, scratch) else if (layout_type .eq. layout_2d) then call cffts1(-1, dims(1,3), dims(2,3), dims(3,3),  & &                  x1, x1, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_x_z(3, 2, x1, x2) if (timers_enabled) call timer_stop(T_transpose) call cffts1(-1, dims(1,2), dims(2,2), dims(3,2),  & &                  x2, x2, scratch) if (timers_enabled) call timer_start(T_transpose) call transpose_x_y(2, 1, x2, x1) if (timers_enabled) call timer_stop(T_transpose) call cffts1(-1, dims(1,1), dims(2,1), dims(3,1),  & &                  x1, x2, scratch) endif endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine cffts1(is, d1, d2, d3, x, xout, y) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer is, d1, d2, d3, logd1 double complex x(d1,d2,d3) double complex xout(d1,d2,d3) double complex y(fftblockpad, d1, 2) integer i, j, k, jj logd1 = ilog2(d1) do k = 1, d3 do jj = 0, d2 - fftblock, fftblock if (timers_enabled) call timer_start(T_fftcopy) do j = 1, fftblock do i = 1, d1 y(j,i,1) = x(i,j+jj,k) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) if (timers_enabled) call timer_start(T_fftlow) call cfftz (is, logd1, d1, y, y(1,1,2)) if (timers_enabled) call timer_stop(T_fftlow) if (timers_enabled) call timer_start(T_fftcopy) do j = 1, fftblock do i = 1, d1 xout(i,j+jj,k) = y(j,i,1) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) enddo enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine cffts2(is, d1, d2, d3, x, xout, y) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer is, d1, d2, d3, logd2 double complex x(d1,d2,d3) double complex xout(d1,d2,d3) double complex y(fftblockpad, d2, 2) integer i, j, k, ii logd2 = ilog2(d2) do k = 1, d3 do ii = 0, d1 - fftblock, fftblock if (timers_enabled) call timer_start(T_fftcopy) do j = 1, d2 do i = 1, fftblock y(i,j,1) = x(i+ii,j,k) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) if (timers_enabled) call timer_start(T_fftlow) call cfftz (is, logd2, d2, y, y(1, 1, 2)) if (timers_enabled) call timer_stop(T_fftlow) if (timers_enabled) call timer_start(T_fftcopy) do j = 1, d2 do i = 1, fftblock xout(i+ii,j,k) = y(i,j,1) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) enddo enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine cffts3(is, d1, d2, d3, x, xout, y) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer is, d1, d2, d3, logd3 double complex x(d1,d2,d3) double complex xout(d1,d2,d3) double complex y(fftblockpad, d3, 2) integer i, j, k, ii logd3 = ilog2(d3) do j = 1, d2 do ii = 0, d1 - fftblock, fftblock if (timers_enabled) call timer_start(T_fftcopy) do k = 1, d3 do i = 1, fftblock y(i,k,1) = x(i+ii,j,k) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) if (timers_enabled) call timer_start(T_fftlow) call cfftz (is, logd3, d3, y, y(1, 1, 2)) if (timers_enabled) call timer_stop(T_fftlow) if (timers_enabled) call timer_start(T_fftcopy) do k = 1, d3 do i = 1, fftblock xout(i+ii,j,k) = y(i,k,1) enddo enddo if (timers_enabled) call timer_stop(T_fftcopy) enddo enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine fft_init (n) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- ! compute the roots-of-unity array that will be used for subsequent FFTs. !--------------------------------------------------------------------- use ft_data implicit none integer m,n,nu,ku,i,j,ln double precision t, ti !--------------------------------------------------------------------- !   Initialize the U array with sines and cosines in a manner that permits !   stride one access at each FFT iteration. !--------------------------------------------------------------------- nu = n m = ilog2(n) u(1) = m ku = 2 ln = 1 do j = 1, m t = pi / ln do i = 0, ln - 1 ti = i * t u(i+ku) = dcmplx (cos (ti), sin(ti)) enddo ku = ku + ln ln = 2 * ln enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine cfftz (is, m, n, x, y) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !   Computes NY N-point complex-to-complex FFTs of X using an algorithm due !   to Swarztrauber.  X is both the input and the output array, while Y is a !   scratch array.  It is assumed that N = 2^M.  Before calling CFFTZ to !   perform FFTs, the array U must be initialized by calling CFFTZ with IS !   set to 0 and M set to MX, where MX is the maximum value of M for any !   subsequent call. !--------------------------------------------------------------------- use ft_data implicit none integer is,m,n,i,j,l,mx double complex x, y dimension x(fftblockpad,n), y(fftblockpad,n) !--------------------------------------------------------------------- !   Check if input parameters are invalid. !--------------------------------------------------------------------- mx = u(1) if ((is .ne. 1 .and. is .ne. -1) .or. m .lt. 1 .or. m .gt. mx)    & &  then write (*, 1)  is, m, mx 1      format ('CFFTZ: Either U has not been initialized, or else'/    & &    'one of the input parameters is invalid', 3I5) stop endif !--------------------------------------------------------------------- !   Perform one variant of the Stockham FFT. !--------------------------------------------------------------------- do l = 1, m, 2 call fftz2 (is, l, m, n, fftblock, fftblockpad, u, x, y) if (l .eq. m) goto 160 call fftz2 (is, l + 1, m, n, fftblock, fftblockpad, u, y, x) enddo goto 180 !--------------------------------------------------------------------- !   Copy Y to X. !--------------------------------------------------------------------- 160  do j = 1, n do i = 1, fftblock x(i,j) = y(i,j) enddo enddo 180  continue return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine fftz2 (is, l, m, n, ny, ny1, u, x, y) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !   Performs the L-th iteration of the second variant of the Stockham FFT. !--------------------------------------------------------------------- implicit none integer is,k,l,m,n,ny,ny1,n1,li,lj,lk,ku,i,j,i11,i12,i21,i22 double complex u,x,y,u1,x11,x21 dimension u(n), x(ny1,n), y(ny1,n) !--------------------------------------------------------------------- !   Set initial parameters. !--------------------------------------------------------------------- n1 = n / 2 lk = 2 ** (l - 1) li = 2 ** (m - l) lj = 2 * lk ku = li + 1 do i = 0, li - 1 i11 = i * lk + 1 i12 = i11 + n1 i21 = i * lj + 1 i22 = i21 + lk if (is .ge. 1) then u1 = u(ku+i) else u1 = dconjg (u(ku+i)) endif !--------------------------------------------------------------------- !   This loop is vectorizable. !--------------------------------------------------------------------- do k = 0, lk - 1 do j = 1, ny x11 = x(j,i11+k) x21 = x(j,i12+k) y(j,i21+k) = x11 + x21 y(j,i22+k) = u1 * (x11 - x21) enddo enddo enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- integer function ilog2(n) !--------------------------------------------------------------------- !--------------------------------------------------------------------- implicit none integer n, nn, lg if (n .eq. 1) then ilog2=0 return endif lg = 1 nn = 2 do while (nn .lt. n) nn = nn*2 lg = lg+1 end do ilog2 = lg return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose_x_yz(l1, l2, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer l1, l2 double complex xin(ntdivnp), xout(ntdivnp) call transpose2_local(dims(1,l1),dims(2, l1)*dims(3, l1),  & &                          xin, xout) call transpose2_global(xout, xin) call transpose2_finish(dims(1,l1),dims(2, l1)*dims(3, l1),  & &                          xin, xout) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose_xy_z(l1, l2, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer l1, l2 double complex xin(ntdivnp), xout(ntdivnp) call transpose2_local(dims(1,l1)*dims(2, l1),dims(3, l1),  & &                          xin, xout) call transpose2_global(xout, xin) call transpose2_finish(dims(1,l1)*dims(2, l1),dims(3, l1),  & &                          xin, xout) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose2_local(n1, n2, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data use mpinpb implicit none integer n1, n2 double complex xin(n1, n2), xout(n2, n1) double complex z(transblockpad, transblock) integer i, j, ii, jj if (timers_enabled) call timer_start(T_transxzloc) !--------------------------------------------------------------------- ! If possible, block the transpose for cache memory systems. ! How much does this help? Example: R8000 Power Challenge (90 MHz) ! Blocked version decreases time spend in this routine ! from 14 seconds to 5.2 seconds on 8 nodes class A. !--------------------------------------------------------------------- if (n1 .lt. transblock .or. n2 .lt. transblock) then if (n1 .ge. n2) then do j = 1, n2 do i = 1, n1 xout(j, i) = xin(i, j) end do end do else do i = 1, n1 do j = 1, n2 xout(j, i) = xin(i, j) end do end do endif else do j = 0, n2-1, transblock do i = 0, n1-1, transblock !--------------------------------------------------------------------- ! Note: compiler should be able to take j+jj out of inner loop !--------------------------------------------------------------------- do jj = 1, transblock do ii = 1, transblock z(jj,ii) = xin(i+ii, j+jj) end do end do do ii = 1, transblock do jj = 1, transblock xout(j+jj, i+ii) = z(jj,ii) end do end do end do end do endif if (timers_enabled) call timer_stop(T_transxzloc) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose2_global(xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data use mpinpb implicit none double complex xin(ntdivnp) double complex xout(ntdivnp) integer ierr !      if (timers_enabled) call synchup() if (timers_enabled) call timer_start(T_transxzglo) call mpi_alltoall(xin, ntdivnp/np_min, dc_type,  & &                  xout, ntdivnp/np_min, dc_type,  & &                  commslice1, ierr) if (timers_enabled) call timer_stop(T_transxzglo) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose2_finish(n1, n2, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer n1, n2, ioff double complex xin(n2, n1/np2, 0:np2-1), xout(n2*np2, n1/np2) integer i, j, p if (timers_enabled) call timer_start(T_transxzfin) do p = 0, np2-1 ioff = p*n2 do j = 1, n1/np2 do i = 1, n2 xout(i+ioff, j) = xin(i, j, p) end do end do end do if (timers_enabled) call timer_stop(T_transxzfin) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose_x_z(l1, l2, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer l1, l2 double complex xin(ntdivnp), xout(ntdivnp) call transpose_x_z_local(dims(1,l1),dims(2,l1),dims(3,l1),  & &                         xin, xout) call transpose_x_z_global(dims(1,l1),dims(2,l1),dims(3,l1),  & &                          xout, xin) call transpose_x_z_finish(dims(1,l2),dims(2,l2),dims(3,l2),  & &                          xin, xout) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine transpose_x_z_local(d1, d2, d3, xin, xout) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use ft_data implicit none integer d1, d2, d3 double complex xin(d1,d2,d3) double complex xout(d3,d2,d1) integer block1, block3 integer i, j, k, kk, ii, i1, k1 double complex buf(transblockpad, maxdim) if (timers_enabled) call timer_start(T_transxzloc) if (d1 .lt. 32) goto 100 block3 = d3 if (block3 .eq. 1)  goto 100 if (block3 .gt. transblock) block3 = transblock block1 = d1 if (block1*block3 .gt. transblock*transblock)  & &          block1 = transblock*transblock/block3 !--------------------------------------------------------------------- ! blocked transpose !--------------------------------------------------------------------- do j = 1, d2 do kk = 0, d3-block3, block3 do ii = 0, d1-block1, block1 do k = 1, block3 k1 = k + kk do i = 1, block1 buf(k, i) = xin(i+ii, j, k1) end do end do do i = 1, block1 i1 = i + ii do k = 1, block3 xout(k+kk, j, i1) = buf(k, i) end do end do end do end do end do goto 200 100  continue do j = 1, d2 do k = 1, d3 do i = 1, d1 xout(k, j, i) = xin(i, j, k) end do end do end do 200  continue if (timers_enabled) call timer_stop(T_transxzloc) return end subroutine transpose_x_z_global(d1, d2, d3, xin, xout) use ft_data use mpinpb implicit none integer d1, d2, d3 double complex xin(d3,d2,d1) double complex xout(d3,d2,d1) integer ierr if (timers_enabled)call timer_start(T_transxzglo) call mpi_alltoall(xin, d1*d2*d3/np2, dc_type,  & &                  xout, d1*d2*d3/np2, dc_type,  & &                  commslice1, ierr) if (timers_enabled) call timer_stop(T_transxzglo) return end subroutine transpose_x_z_finish(d1, d2, d3, xin, xout) use ft_data implicit none integer d1, d2, d3 double complex xin(d1/np2, d2, d3, 0:np2-1) double complex xout(d1,d2,d3) integer i, j, k, p, ioff if (timers_enabled) call timer_start(T_transxzfin) do p = 0, np2-1 ioff = p*d1/np2 do k = 1, d3 do j = 1, d2 do i = 1, d1/np2 xout(i+ioff, j, k) = xin(i, j, k, p) end do end do end do end do if (timers_enabled) call timer_stop(T_transxzfin) return end subroutine transpose_x_y(l1, l2, xin, xout) use ft_data implicit none integer l1, l2 double complex xin(ntdivnp), xout(ntdivnp) call transpose_x_y_local(dims(1,l1),dims(2,l1),dims(3,l1),  & &                         xin, xout) call transpose_x_y_global(dims(1,l1),dims(2,l1),dims(3,l1),  & &                          xout, xin) call transpose_x_y_finish(dims(1,l2),dims(2,l2),dims(3,l2),  & &                          xin, xout) return end subroutine transpose_x_y_local(d1, d2, d3, xin, xout) use ft_data implicit none integer d1, d2, d3 double complex xin(d1, d2, d3) double complex xout(d2, d3, d1) integer i, j, k if (timers_enabled) call timer_start(T_transxyloc) do k = 1, d3 do i = 1, d1 do j = 1, d2 xout(j,k,i)=xin(i,j,k) end do end do end do if (timers_enabled) call timer_stop(T_transxyloc) return end subroutine transpose_x_y_global(d1, d2, d3, xin, xout) use ft_data use mpinpb implicit none integer d1, d2, d3 double complex xin(d2,d3,d1) double complex xout(d2,d3,d1) integer ierr if (timers_enabled) call timer_start(T_transxyglo) call mpi_alltoall(xin, d1*d2*d3/np1, dc_type,  & &                  xout, d1*d2*d3/np1, dc_type,  & &                  commslice2, ierr) if (timers_enabled) call timer_stop(T_transxyglo) return end subroutine transpose_x_y_finish(d1, d2, d3, xin, xout) use ft_data implicit none integer d1, d2, d3 double complex xin(d1/np1, d3, d2, 0:np1-1) double complex xout(d1,d2,d3) integer i, j, k, p, ioff if (timers_enabled) call timer_start(T_transxyfin) do p = 0, np1-1 ioff = p*d1/np1 do k = 1, d3 do j = 1, d2 do i = 1, d1/np1 xout(i+ioff, j, k) = xin(i, k, j, p) end do end do end do end do if (timers_enabled) call timer_stop(T_transxyfin) return end subroutine checksum(i, u1, d1, d2, d3) use ft_data use mpinpb implicit none integer i, d1, d2, d3 double complex u1(d1, d2, d3) integer j, q,r,s, ierr double complex chk,allchk chk = (0.0,0.0) do j=1,1024 q = mod(j, nx)+1 if (q .ge. xstart(1) .and. q .le. xend(1)) then r = mod(3*j,ny)+1 if (r .ge. ystart(1) .and. r .le. yend(1)) then s = mod(5*j,nz)+1 if (s .ge. zstart(1) .and. s .le. zend(1)) then chk=chk+u1(q-xstart(1)+1,r-ystart(1)+1,s-zstart(1)+1) end if end if end if end do chk = chk/ntotal_f if (timers_enabled) call timer_start(T_synch) call MPI_Reduce(chk, allchk, 1, dc_type, MPI_SUM,  & &                0, comm_solve, ierr) if (timers_enabled) call timer_stop(T_synch) if (me .eq. 0) then write (*, 30) i, allchk 30         format (' T =',I5,5X,'Checksum =',1P2D22.12) endif if (i .gt. 0) sums(i) = allchk return end subroutine synchup use ft_data use mpinpb implicit none integer ierr call timer_start(T_synch) call mpi_barrier(comm_solve, ierr) call timer_stop(T_synch) return end subroutine set_class (d1, d2, d3, nt, class) implicit none integer d1, d2, d3, nt character class class = 'U' if (d1 .eq. 64 .and.  & &    d2 .eq. 64 .and.  & &    d3 .eq. 64 .and.  & &    nt .eq. 6) then class = 'S' else if (d1 .eq. 128 .and.  & &    d2 .eq. 128 .and.  & &    d3 .eq. 32 .and.  & &    nt .eq. 6) then class = 'W' else if (d1 .eq. 256 .and.  & &    d2 .eq. 256 .and.  & &    d3 .eq. 128 .and.  & &    nt .eq. 6) then class = 'A' else if (d1 .eq. 512 .and.  & &    d2 .eq. 256 .and.  & &    d3 .eq. 256 .and.  & &    nt .eq. 20) then class = 'B' else if (d1 .eq. 512 .and.  & &    d2 .eq. 512 .and.  & &    d3 .eq. 512 .and.  & &    nt .eq. 20) then class = 'C' else if (d1 .eq. 2048 .and.  & &    d2 .eq. 1024 .and.  & &    d3 .eq. 1024 .and.  & &    nt .eq. 25) then class = 'D' else if (d1 .eq. 4096 .and.  & &    d2 .eq. 2048 .and.  & &    d3 .eq. 2048 .and.  & &    nt .eq. 25) then class = 'E' else if (d1 .eq. 8192 .and.  & &    d2 .eq. 4096 .and.  & &    d3 .eq. 4096 .and.  & &    nt .eq. 25) then class = 'F' endif return end subroutine verify (nt, verified, class) use, intrinsic :: ieee_arithmetic, only : ieee_is_nan use ft_data use mpinpb implicit none integer nt character class logical verified integer ierr, size, i double precision err, epsilon double complex csum_ref(25) if (me .ne. 0) return epsilon = 1.0d-12 verified = .FALSE. if ( class .eq. 'S' ) then csum_ref(1) = dcmplx(5.546087004964D+02, 4.845363331978D+02) csum_ref(2) = dcmplx(5.546385409189D+02, 4.865304269511D+02) csum_ref(3) = dcmplx(5.546148406171D+02, 4.883910722336D+02) csum_ref(4) = dcmplx(5.545423607415D+02, 4.901273169046D+02) csum_ref(5) = dcmplx(5.544255039624D+02, 4.917475857993D+02) csum_ref(6) = dcmplx(5.542683411902D+02, 4.932597244941D+02) else if ( class .eq. 'W' ) then csum_ref(1) = dcmplx(5.673612178944D+02, 5.293246849175D+02) csum_ref(2) = dcmplx(5.631436885271D+02, 5.282149986629D+02) csum_ref(3) = dcmplx(5.594024089970D+02, 5.270996558037D+02) csum_ref(4) = dcmplx(5.560698047020D+02, 5.260027904925D+02) csum_ref(5) = dcmplx(5.530898991250D+02, 5.249400845633D+02) csum_ref(6) = dcmplx(5.504159734538D+02, 5.239212247086D+02) else if ( class .eq. 'A' ) then csum_ref(1) = dcmplx(5.046735008193D+02, 5.114047905510D+02) csum_ref(2) = dcmplx(5.059412319734D+02, 5.098809666433D+02) csum_ref(3) = dcmplx(5.069376896287D+02, 5.098144042213D+02) csum_ref(4) = dcmplx(5.077892868474D+02, 5.101336130759D+02) csum_ref(5) = dcmplx(5.085233095391D+02, 5.104914655194D+02) csum_ref(6) = dcmplx(5.091487099959D+02, 5.107917842803D+02) else if ( class .eq. 'B' ) then csum_ref(1)  = dcmplx(5.177643571579D+02, 5.077803458597D+02) csum_ref(2)  = dcmplx(5.154521291263D+02, 5.088249431599D+02) csum_ref(3)  = dcmplx(5.146409228649D+02, 5.096208912659D+02) csum_ref(4)  = dcmplx(5.142378756213D+02, 5.101023387619D+02) csum_ref(5)  = dcmplx(5.139626667737D+02, 5.103976610617D+02) csum_ref(6)  = dcmplx(5.137423460082D+02, 5.105948019802D+02) csum_ref(7)  = dcmplx(5.135547056878D+02, 5.107404165783D+02) csum_ref(8)  = dcmplx(5.133910925466D+02, 5.108576573661D+02) csum_ref(9)  = dcmplx(5.132470705390D+02, 5.109577278523D+02) csum_ref(10) = dcmplx(5.131197729984D+02, 5.110460304483D+02) csum_ref(11) = dcmplx(5.130070319283D+02, 5.111252433800D+02) csum_ref(12) = dcmplx(5.129070537032D+02, 5.111968077718D+02) csum_ref(13) = dcmplx(5.128182883502D+02, 5.112616233064D+02) csum_ref(14) = dcmplx(5.127393733383D+02, 5.113203605551D+02) csum_ref(15) = dcmplx(5.126691062020D+02, 5.113735928093D+02) csum_ref(16) = dcmplx(5.126064276004D+02, 5.114218460548D+02) csum_ref(17) = dcmplx(5.125504076570D+02, 5.114656139760D+02) csum_ref(18) = dcmplx(5.125002331720D+02, 5.115053595966D+02) csum_ref(19) = dcmplx(5.124551951846D+02, 5.115415130407D+02) csum_ref(20) = dcmplx(5.124146770029D+02, 5.115744692211D+02) else if ( class .eq. 'C' ) then csum_ref(1)  = dcmplx(5.195078707457D+02, 5.149019699238D+02) csum_ref(2)  = dcmplx(5.155422171134D+02, 5.127578201997D+02) csum_ref(3)  = dcmplx(5.144678022222D+02, 5.122251847514D+02) csum_ref(4)  = dcmplx(5.140150594328D+02, 5.121090289018D+02) csum_ref(5)  = dcmplx(5.137550426810D+02, 5.121143685824D+02) csum_ref(6)  = dcmplx(5.135811056728D+02, 5.121496764568D+02) csum_ref(7)  = dcmplx(5.134569343165D+02, 5.121870921893D+02) csum_ref(8)  = dcmplx(5.133651975661D+02, 5.122193250322D+02) csum_ref(9)  = dcmplx(5.132955192805D+02, 5.122454735794D+02) csum_ref(10) = dcmplx(5.132410471738D+02, 5.122663649603D+02) csum_ref(11) = dcmplx(5.131971141679D+02, 5.122830879827D+02) csum_ref(12) = dcmplx(5.131605205716D+02, 5.122965869718D+02) csum_ref(13) = dcmplx(5.131290734194D+02, 5.123075927445D+02) csum_ref(14) = dcmplx(5.131012720314D+02, 5.123166486553D+02) csum_ref(15) = dcmplx(5.130760908195D+02, 5.123241541685D+02) csum_ref(16) = dcmplx(5.130528295923D+02, 5.123304037599D+02) csum_ref(17) = dcmplx(5.130310107773D+02, 5.123356167976D+02) csum_ref(18) = dcmplx(5.130103090133D+02, 5.123399592211D+02) csum_ref(19) = dcmplx(5.129905029333D+02, 5.123435588985D+02) csum_ref(20) = dcmplx(5.129714421109D+02, 5.123465164008D+02) else if ( class .eq. 'D' ) then csum_ref(1)  = dcmplx(5.122230065252D+02, 5.118534037109D+02) csum_ref(2)  = dcmplx(5.120463975765D+02, 5.117061181082D+02) csum_ref(3)  = dcmplx(5.119865766760D+02, 5.117096364601D+02) csum_ref(4)  = dcmplx(5.119518799488D+02, 5.117373863950D+02) csum_ref(5)  = dcmplx(5.119269088223D+02, 5.117680347632D+02) csum_ref(6)  = dcmplx(5.119082416858D+02, 5.117967875532D+02) csum_ref(7)  = dcmplx(5.118943814638D+02, 5.118225281841D+02) csum_ref(8)  = dcmplx(5.118842385057D+02, 5.118451629348D+02) csum_ref(9)  = dcmplx(5.118769435632D+02, 5.118649119387D+02) csum_ref(10) = dcmplx(5.118718203448D+02, 5.118820803844D+02) csum_ref(11) = dcmplx(5.118683569061D+02, 5.118969781011D+02) csum_ref(12) = dcmplx(5.118661708593D+02, 5.119098918835D+02) csum_ref(13) = dcmplx(5.118649768950D+02, 5.119210777066D+02) csum_ref(14) = dcmplx(5.118645605626D+02, 5.119307604484D+02) csum_ref(15) = dcmplx(5.118647586618D+02, 5.119391362671D+02) csum_ref(16) = dcmplx(5.118654451572D+02, 5.119463757241D+02) csum_ref(17) = dcmplx(5.118665212451D+02, 5.119526269238D+02) csum_ref(18) = dcmplx(5.118679083821D+02, 5.119580184108D+02) csum_ref(19) = dcmplx(5.118695433664D+02, 5.119626617538D+02) csum_ref(20) = dcmplx(5.118713748264D+02, 5.119666538138D+02) csum_ref(21) = dcmplx(5.118733606701D+02, 5.119700787219D+02) csum_ref(22) = dcmplx(5.118754661974D+02, 5.119730095953D+02) csum_ref(23) = dcmplx(5.118776626738D+02, 5.119755100241D+02) csum_ref(24) = dcmplx(5.118799262314D+02, 5.119776353561D+02) csum_ref(25) = dcmplx(5.118822370068D+02, 5.119794338060D+02) else if ( class .eq. 'E' ) then csum_ref(1)  = dcmplx(5.121601045346D+02, 5.117395998266D+02) csum_ref(2)  = dcmplx(5.120905403678D+02, 5.118614716182D+02) csum_ref(3)  = dcmplx(5.120623229306D+02, 5.119074203747D+02) csum_ref(4)  = dcmplx(5.120438418997D+02, 5.119345900733D+02) csum_ref(5)  = dcmplx(5.120311521872D+02, 5.119551325550D+02) csum_ref(6)  = dcmplx(5.120226088809D+02, 5.119720179919D+02) csum_ref(7)  = dcmplx(5.120169296534D+02, 5.119861371665D+02) csum_ref(8)  = dcmplx(5.120131225172D+02, 5.119979364402D+02) csum_ref(9)  = dcmplx(5.120104767108D+02, 5.120077674092D+02) csum_ref(10) = dcmplx(5.120085127969D+02, 5.120159443121D+02) csum_ref(11) = dcmplx(5.120069224127D+02, 5.120227453670D+02) csum_ref(12) = dcmplx(5.120055158164D+02, 5.120284096041D+02) csum_ref(13) = dcmplx(5.120041820159D+02, 5.120331373793D+02) csum_ref(14) = dcmplx(5.120028605402D+02, 5.120370938679D+02) csum_ref(15) = dcmplx(5.120015223011D+02, 5.120404138831D+02) csum_ref(16) = dcmplx(5.120001570022D+02, 5.120432068837D+02) csum_ref(17) = dcmplx(5.119987650555D+02, 5.120455615860D+02) csum_ref(18) = dcmplx(5.119973525091D+02, 5.120475499442D+02) csum_ref(19) = dcmplx(5.119959279472D+02, 5.120492304629D+02) csum_ref(20) = dcmplx(5.119945006558D+02, 5.120506508902D+02) csum_ref(21) = dcmplx(5.119930795911D+02, 5.120518503782D+02) csum_ref(22) = dcmplx(5.119916728462D+02, 5.120528612016D+02) csum_ref(23) = dcmplx(5.119902874185D+02, 5.120537101195D+02) csum_ref(24) = dcmplx(5.119889291565D+02, 5.120544194514D+02) csum_ref(25) = dcmplx(5.119876028049D+02, 5.120550079284D+02) else if ( class .eq. 'F' ) then csum_ref( 1) = dcmplx(5.119892866928D+02, 5.121457822747D+02) csum_ref( 2) = dcmplx(5.119560157487D+02, 5.121009044434D+02) csum_ref( 3) = dcmplx(5.119437960123D+02, 5.120761074285D+02) csum_ref( 4) = dcmplx(5.119395628845D+02, 5.120614320496D+02) csum_ref( 5) = dcmplx(5.119390371879D+02, 5.120514085624D+02) csum_ref( 6) = dcmplx(5.119405091840D+02, 5.120438117102D+02) csum_ref( 7) = dcmplx(5.119430444528D+02, 5.120376348915D+02) csum_ref( 8) = dcmplx(5.119460702242D+02, 5.120323831062D+02) csum_ref( 9) = dcmplx(5.119492377036D+02, 5.120277980818D+02) csum_ref(10) = dcmplx(5.119523446268D+02, 5.120237368268D+02) csum_ref(11) = dcmplx(5.119552825361D+02, 5.120201137845D+02) csum_ref(12) = dcmplx(5.119580008777D+02, 5.120168723492D+02) csum_ref(13) = dcmplx(5.119604834177D+02, 5.120139707209D+02) csum_ref(14) = dcmplx(5.119627332821D+02, 5.120113749334D+02) csum_ref(15) = dcmplx(5.119647637538D+02, 5.120090554887D+02) csum_ref(16) = dcmplx(5.119665927740D+02, 5.120069857863D+02) csum_ref(17) = dcmplx(5.119682397643D+02, 5.120051414260D+02) csum_ref(18) = dcmplx(5.119697238718D+02, 5.120034999132D+02) csum_ref(19) = dcmplx(5.119710630664D+02, 5.120020405355D+02) csum_ref(20) = dcmplx(5.119722737384D+02, 5.120007442976D+02) csum_ref(21) = dcmplx(5.119733705802D+02, 5.119995938652D+02) csum_ref(22) = dcmplx(5.119743666226D+02, 5.119985735001D+02) csum_ref(23) = dcmplx(5.119752733481D+02, 5.119976689792D+02) csum_ref(24) = dcmplx(5.119761008382D+02, 5.119968675026D+02) csum_ref(25) = dcmplx(5.119768579280D+02, 5.119961575929D+02) endif if (class .ne. 'U') then do i = 1, nt err = abs( (sums(i) - csum_ref(i)) / csum_ref(i) ) if (ieee_is_nan(err) .or. (err .gt. epsilon)) goto 100 end do verified = .TRUE. 100     continue endif if (class .ne. 'U') then if (verified) then write(*,2000) 2000       format(' Result verification successful') else write(*,2001) 2001       format(' Result verification failed') endif endif return end
program applu use lu_data use mpinpb use timing implicit none character class logical verified double precision mflops, timer_read integer i, ierr double precision tsum(t_last+2), t1(t_last+2),  & &                 tming(t_last+2), tmaxg(t_last+2) character        t_recs(t_last+2)*8 data t_recs/'total', 'rhs', 'blts', 'buts', '#jacld', '#jacu',  & &            'exch', 'lcomm', 'ucomm', 'rcomm',  & &            ' totcomp', ' totcomm'/ !--------------------------------------------------------------------- !   initialize communications !--------------------------------------------------------------------- call init_comm() if (.not. active) goto 999 !--------------------------------------------------------------------- !   read input data !--------------------------------------------------------------------- call read_input(class) do i = 1, t_last call timer_clear(i) end do !--------------------------------------------------------------------- !   set up processor grid !--------------------------------------------------------------------- call proc_grid() !--------------------------------------------------------------------- !   allocate space !--------------------------------------------------------------------- call alloc_space() !--------------------------------------------------------------------- !   determine the neighbors !--------------------------------------------------------------------- call neighbors() !--------------------------------------------------------------------- !   set up sub-domain sizes !--------------------------------------------------------------------- call subdomain() !--------------------------------------------------------------------- !   set up coefficients !--------------------------------------------------------------------- call setcoeff() !--------------------------------------------------------------------- !   set the boundary values for dependent variables !--------------------------------------------------------------------- call setbv() !--------------------------------------------------------------------- !   set the initial values for dependent variables !--------------------------------------------------------------------- call setiv() !--------------------------------------------------------------------- !   compute the forcing term based on prescribed exact solution !--------------------------------------------------------------------- call erhs() !--------------------------------------------------------------------- !   perform one SSOR iteration to touch all data and program pages !--------------------------------------------------------------------- call ssor(1) !--------------------------------------------------------------------- !   reset the boundary and initial values !--------------------------------------------------------------------- call setbv() call setiv() !--------------------------------------------------------------------- !   perform the SSOR iterations !--------------------------------------------------------------------- call ssor(itmax) !--------------------------------------------------------------------- !   compute the solution error !--------------------------------------------------------------------- call error() !--------------------------------------------------------------------- !   compute the surface integral !--------------------------------------------------------------------- call pintgr() !--------------------------------------------------------------------- !   verification test !--------------------------------------------------------------------- IF (id.eq.0) THEN call verify ( rsdnm, errnm, frc, class, verified ) mflops = 1.0d-6*dble(itmax)*(1984.77*dble( nx0 )  & &        *dble( ny0 )  & &        *dble( nz0 )  & &        -10923.3*(dble( nx0+ny0+nz0 )/3.)**2  & &        +27770.9* dble( nx0+ny0+nz0 )/3.  & &        -144010.)  & &        / maxtime call print_results('LU', class, nx0,  & &     ny0, nz0, itmax, no_nodes, total_nodes,  & &     maxtime, mflops, '          floating point', verified,  & &     npbversion, compiletime, cs1, cs2, cs3, cs4, cs5, cs6,  & &     '(none)') END IF if (.not.timeron) goto 999 do i = 1, t_last t1(i) = timer_read(i) end do t1(t_rhs) = t1(t_rhs) - t1(t_exch) t1(t_last+2) = t1(t_lcomm)+t1(t_ucomm)+t1(t_rcomm)+t1(t_exch) t1(t_last+1) = t1(t_total) - t1(t_last+2) call MPI_Reduce(t1, tsum,  t_last+2, dp_type, MPI_SUM,  & &                0, comm_solve, ierr) call MPI_Reduce(t1, tming, t_last+2, dp_type, MPI_MIN,  & &                0, comm_solve, ierr) call MPI_Reduce(t1, tmaxg, t_last+2, dp_type, MPI_MAX,  & &                0, comm_solve, ierr) if (id .eq. 0) then write(*, 800) no_nodes do i = 1, t_last+2 if (t_recs(i)(1:1) .ne. '#') then tsum(i) = tsum(i) / no_nodes write(*, 810) i, t_recs(i), tming(i), tmaxg(i), tsum(i) endif end do endif 800  format(' nprocs =', i6, 11x, 'minimum', 5x, 'maximum',  & &       5x, 'average') 810  format(' timer ', i2, '(', A8, ') :', 3(2x,f10.4)) 999  continue call mpi_finalize(ierr) end
program mg_mpi use, intrinsic :: ieee_arithmetic, only : ieee_is_nan use mg_data use mg_fields use mpinpb implicit none integer k, it external timer_read double precision t, t0, tinit, mflops, timer_read double precision rnm2, rnmu, old2, oldu, epsilon integer n1, n2, n3, nit, i double precision nn, verify_value, err logical verified integer ierr, fstatus double precision tsum(t_last+2), t1(t_last+2),  & &                 tming(t_last+2), tmaxg(t_last+2) character        t_recs(t_last+2)*8 data t_recs/'total', 'init', 'psinv', 'resid', 'rprj3',  & &            'interp', 'norm2u3', 'comm3', 'rcomm',  & &            ' totcomp', ' totcomm'/ call mpi_init(ierr) call get_active_nprocs(3, n1, n2, nprocs,  & &                       nprocs_total, me, comm_work, active) if (.not. active) goto 999 root = 0 if (.not. convertdouble) then dp_type = MPI_DOUBLE_PRECISION else dp_type = MPI_REAL endif if (nprocs .gt. maxprocs) then if (me .eq. root) write(*,20) nprocs_total, maxprocs 20      format(' ERROR: requested for ',i8,' processes'//  & &          ' The maximum size allowed for this benchmark is ',i6) call mpi_abort(mpi_comm_world, 1, ierr) stop endif call alloc_space do i = 1, t_last call timer_clear(i) end do call mpi_barrier(comm_work, ierr) call timer_start(T_init) !--------------------------------------------------------------------- ! Read in and broadcast input data !--------------------------------------------------------------------- if( me .eq. root )then write (*, 1000) call check_timer_flag( timeron ) open(unit=7,file="mg.input", status="old", iostat=fstatus) if (fstatus .eq. 0) then write(*,50) 50         format(' Reading from input file mg.input') read(7,*) lt read(7,*) nx(lt), ny(lt), nz(lt) read(7,*) nit read(7,*) (debug_vec(i),i=0,7) else write(*,51) 51         format(' No input file. Using compiled defaults ') lt = lt_default nit = nit_default nx(lt) = nx_default ny(lt) = ny_default nz(lt) = nz_default do i = 0,7 debug_vec(i) = debug_default end do endif endif call mpi_bcast(lt, 1, MPI_INTEGER, 0, comm_work, ierr) call mpi_bcast(nit, 1, MPI_INTEGER, 0, comm_work, ierr) call mpi_bcast(nx(lt), 1, MPI_INTEGER, 0, comm_work, ierr) call mpi_bcast(ny(lt), 1, MPI_INTEGER, 0, comm_work, ierr) call mpi_bcast(nz(lt), 1, MPI_INTEGER, 0, comm_work, ierr) call mpi_bcast(debug_vec(0), 8, MPI_INTEGER, 0,  & &               comm_work, ierr) call mpi_bcast(timeron, 1, MPI_LOGICAL, 0, comm_work, ierr) if ( (nx(lt) .ne. ny(lt)) .or. (nx(lt) .ne. nz(lt)) ) then Class = 'U' else if( nx(lt) .eq. 32 .and. nit .eq. 4 ) then Class = 'S' else if( nx(lt) .eq. 128 .and. nit .eq. 4 ) then Class = 'W' else if( nx(lt) .eq. 256 .and. nit .eq. 4 ) then Class = 'A' else if( nx(lt) .eq. 256 .and. nit .eq. 20 ) then Class = 'B' else if( nx(lt) .eq. 512 .and. nit .eq. 20 ) then Class = 'C' else if( nx(lt) .eq. 1024 .and. nit .eq. 50 ) then Class = 'D' else if( nx(lt) .eq. 2048 .and. nit .eq. 50 ) then Class = 'E' else if( nx(lt) .eq. 4096 .and. nit .eq. 50 ) then Class = 'F' else Class = 'U' endif !--------------------------------------------------------------------- !  Use these for debug info: !--------------------------------------------------------------------- !     debug_vec(0) = 1 !=> report all norms !     debug_vec(1) = 1 !=> some setup information !     debug_vec(1) = 2 !=> more setup information !     debug_vec(2) = k => at level k or below, show result of resid !     debug_vec(3) = k => at level k or below, show result of psinv !     debug_vec(4) = k => at level k or below, show result of rprj !     debug_vec(5) = k => at level k or below, show result of interp !     debug_vec(6) = 1 => (unused) !     debug_vec(7) = 1 => (unused) !--------------------------------------------------------------------- a(0) = -8.0D0/3.0D0 a(1) =  0.0D0 a(2) =  1.0D0/6.0D0 a(3) =  1.0D0/12.0D0 if(Class .eq. 'A' .or. Class .eq. 'S'.or. Class .eq.'W') then !--------------------------------------------------------------------- !     Coefficients for the S(a) smoother !--------------------------------------------------------------------- c(0) =  -3.0D0/8.0D0 c(1) =  +1.0D0/32.0D0 c(2) =  -1.0D0/64.0D0 c(3) =   0.0D0 else !--------------------------------------------------------------------- !     Coefficients for the S(b) smoother !--------------------------------------------------------------------- c(0) =  -3.0D0/17.0D0 c(1) =  +1.0D0/33.0D0 c(2) =  -1.0D0/61.0D0 c(3) =   0.0D0 endif lb = 1 k  = lt call setup(n1,n2,n3,k) call zero3(u,n1,n2,n3) call zran3(v,n1,n2,n3,nx(lt),ny(lt),k) call norm2u3(v,n1,n2,n3,rnm2,rnmu,nx(lt),ny(lt),nz(lt)) if( me .eq. root )then write (*, 1001) nx(lt),ny(lt),nz(lt), Class write (*, 1002) nit write (*, 1003) nprocs_total if (nprocs .ne. nprocs_total) write (*, 1004) nprocs write (*, *) 1000 format(//,' NAS Parallel Benchmarks 3.4 -- MG Benchmark', /) 1001    format(' Size: ', i4, 'x', i4, 'x', i4, '  (class ', a, ')' ) 1002    format(' Iterations: ', i4) 1003    format(' Total number of processes: ', i6) 1004    format(' WARNING: Number of processes is not power of two (',  & &          i0, ' active)') endif call resid(u,v,r,n1,n2,n3,a,k) call norm2u3(r,n1,n2,n3,rnm2,rnmu,nx(lt),ny(lt),nz(lt)) old2 = rnm2 oldu = rnmu !--------------------------------------------------------------------- !     One iteration for startup !--------------------------------------------------------------------- call mg3P(u,v,r,a,c,n1,n2,n3,k) call resid(u,v,r,n1,n2,n3,a,k) call setup(n1,n2,n3,k) call zero3(u,n1,n2,n3) call zran3(v,n1,n2,n3,nx(lt),ny(lt),k) call timer_stop(T_init) if( me .eq. root )then tinit = timer_read(T_init) write( *,'(/A,F15.3,A/)' )  & &        ' Initialization time: ',tinit, ' seconds' endif do i = 1, t_last if (i .ne. t_init) call timer_clear(i) end do call mpi_barrier(comm_work,ierr) call timer_start(T_bench) call resid(u,v,r,n1,n2,n3,a,k) call norm2u3(r,n1,n2,n3,rnm2,rnmu,nx(lt),ny(lt),nz(lt)) old2 = rnm2 oldu = rnmu do  it=1,nit if (it.eq.1 .or. it.eq.nit .or. mod(it,5).eq.0) then if (me .eq. root) write(*,80) it 80       format('  iter ',i4) endif call mg3P(u,v,r,a,c,n1,n2,n3,k) call resid(u,v,r,n1,n2,n3,a,k) enddo call norm2u3(r,n1,n2,n3,rnm2,rnmu,nx(lt),ny(lt),nz(lt)) call timer_stop(T_bench) t0 = timer_read(T_bench) call mpi_reduce(t0,t,1,dp_type,  & &     mpi_max,root,comm_work,ierr) verified = .FALSE. verify_value = 0.0 if( me .eq. root )then write(*,100) 100     format(/' Benchmark completed ') epsilon = 1.d-8 if (Class .ne. 'U') then if(Class.eq.'S') then verify_value = 0.5307707005734d-04 elseif(Class.eq.'W') then verify_value = 0.6467329375339d-05 elseif(Class.eq.'A') then verify_value = 0.2433365309069d-05 elseif(Class.eq.'B') then verify_value = 0.1800564401355d-05 elseif(Class.eq.'C') then verify_value = 0.5706732285740d-06 elseif(Class.eq.'D') then verify_value = 0.1583275060440d-09 elseif(Class.eq.'E') then verify_value = 0.5630442584711d-10 elseif(Class.eq.'F') then verify_value = 0.1889225697989d-10 endif err = abs( rnm2 - verify_value ) / verify_value if( (.not.ieee_is_nan(err)) .and. (err .le. epsilon) ) then verified = .TRUE. write(*, 200) write(*, 201) rnm2 write(*, 202) err 200           format(' VERIFICATION SUCCESSFUL ') 201           format(' L2 Norm is ', E20.13) 202           format(' Error is   ', E20.13) else verified = .FALSE. write(*, 300) write(*, 301) rnm2 write(*, 302) verify_value 300           format(' VERIFICATION FAILED') 301           format(' L2 Norm is             ', E20.13) 302           format(' The correct L2 Norm is ', E20.13) endif else verified = .FALSE. write (*, 400) write (*, 401) write (*, 201) rnm2 400        format(' Problem size unknown') 401        format(' NO VERIFICATION PERFORMED') endif nn = 1.0d0*nx(lt)*ny(lt)*nz(lt) if( t .ne. 0. ) then mflops = 58.*1.0D-6*nit*nn / t else mflops = 0.0 endif call print_results('MG', class, nx(lt), ny(lt), nz(lt),  & &                      nit, nprocs, nprocs_total, t,  & &                      mflops, '          floating point',  & &                      verified, npbversion, compiletime,  & &                      cs1, cs2, cs3, cs4, cs5, cs6, cs7) endif if (.not.timeron) goto 999 do i = 1, t_last t1(i) = timer_read(i) end do t1(t_last+2) = t1(t_rcomm) + t1(t_comm3) t1(t_last+1) = t1(t_bench) - t1(t_last+2) call MPI_Reduce(t1, tsum,  t_last+2, dp_type, MPI_SUM,  & &                0, comm_work, ierr) call MPI_Reduce(t1, tming, t_last+2, dp_type, MPI_MIN,  & &                0, comm_work, ierr) call MPI_Reduce(t1, tmaxg, t_last+2, dp_type, MPI_MAX,  & &                0, comm_work, ierr) if (me .eq. 0) then write(*, 800) nprocs do i = 1, t_last+2 tsum(i) = tsum(i) / nprocs write(*, 810) i, t_recs(i), tming(i), tmaxg(i), tsum(i) end do endif 800  format(' nprocs =', i6, 11x, 'minimum', 5x, 'maximum',  & &       5x, 'average') 810  format(' timer ', i2, '(', A8, ') :', 3(2x,f10.4)) 999  continue call mpi_finalize(ierr) end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine setup(n1,n2,n3,k) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1,n2,n3,k integer dx, dy, log_p, d, i, j integer ax, next(3),mi(3,maxlevel),mip(3,maxlevel) integer ng(3,maxlevel) integer idi(3), pi(3), idin(3,-1:1) integer s, dir,ierr do  j=-1,1,1 do  d=1,3 msg_type(d,j) = 100*(j+2+10*d) enddo enddo ng(1,lt) = nx(lt) ng(2,lt) = ny(lt) ng(3,lt) = nz(lt) do  ax=1,3 next(ax) = 1 do  k=lt-1,1,-1 ng(ax,k) = ng(ax,k+1)/2 enddo enddo 61   format(10i4) do  k=lt,1,-1 nx(k) = ng(1,k) ny(k) = ng(2,k) nz(k) = ng(3,k) enddo log_p  = log(float(nprocs)+0.0001)/log(2.0) dx     = log_p/3 pi(1)  = 2**dx idi(1) = mod(me,pi(1)) dy     = (log_p-dx)/2 pi(2)  = 2**dy idi(2) = mod((me/pi(1)),pi(2)) pi(3)  = nprocs/(pi(1)*pi(2)) idi(3) = me/(pi(1)*pi(2)) do  k = lt,1,-1 dead(k) = .false. do  ax = 1,3 take_ex(ax,k) = .false. give_ex(ax,k) = .false. mi(ax,k) = 2 +  & &           ((idi(ax)+1)*ng(ax,k))/pi(ax) -  & &           ((idi(ax)+0)*ng(ax,k))/pi(ax) mip(ax,k) = 2 +  & &           ((next(ax)+idi(ax)+1)*ng(ax,k))/pi(ax) -  & &           ((next(ax)+idi(ax)+0)*ng(ax,k))/pi(ax) if(mip(ax,k).eq.2.or.mi(ax,k).eq.2)then next(ax) = 2*next(ax) endif if( k+1 .le. lt )then if((mip(ax,k).eq.2).and.(mi(ax,k).eq.3))then give_ex(ax,k+1) = .true. endif if((mip(ax,k).eq.3).and.(mi(ax,k).eq.2))then take_ex(ax,k+1) = .true. endif endif enddo if( mi(1,k).eq.2 .or.  & &        mi(2,k).eq.2 .or.  & &        mi(3,k).eq.2      )then dead(k) = .true. endif m1(k) = mi(1,k) m2(k) = mi(2,k) m3(k) = mi(3,k) do  ax=1,3 idin(ax,+1) = mod( idi(ax) + next(ax) + pi(ax) , pi(ax) ) idin(ax,-1) = mod( idi(ax) - next(ax) + pi(ax) , pi(ax) ) enddo do  dir = 1,-1,-2 nbr(1,dir,k) = idin(1,dir) + pi(1)  & &           *(idi(2)      + pi(2)  & &           * idi(3)) nbr(2,dir,k) = idi(1)      + pi(1)  & &           *(idin(2,dir) + pi(2)  & &           * idi(3)) nbr(3,dir,k) = idi(1)      + pi(1)  & &           *(idi(2)      + pi(2)  & &           * idin(3,dir)) enddo enddo k = lt is1 = 2 + ng(1,k) - ((pi(1)  -idi(1))*ng(1,lt))/pi(1) ie1 = 1 + ng(1,k) - ((pi(1)-1-idi(1))*ng(1,lt))/pi(1) n1 = 3 + ie1 - is1 is2 = 2 + ng(2,k) - ((pi(2)  -idi(2))*ng(2,lt))/pi(2) ie2 = 1 + ng(2,k) - ((pi(2)-1-idi(2))*ng(2,lt))/pi(2) n2 = 3 + ie2 - is2 is3 = 2 + ng(3,k) - ((pi(3)  -idi(3))*ng(3,lt))/pi(3) ie3 = 1 + ng(3,k) - ((pi(3)-1-idi(3))*ng(3,lt))/pi(3) n3 = 3 + ie3 - is3 ir(lt)=1 do  j = lt-1, 1, -1 ir(j)=ir(j+1)+m1(j+1)*m2(j+1)*m3(j+1) enddo if( debug_vec(1) .ge. 1 )then if( me .eq. root )write(*,*)' in setup, ' if( me .eq. root )write(*,*)' me   k  lt  nx  ny  nz ',  & &        ' n1  n2  n3 is1 is2 is3 ie1 ie2 ie3' do  i=0,nprocs-1 if( me .eq. i )then write(*,9) me,k,lt,ng(1,k),ng(2,k),ng(3,k),  & &              n1,n2,n3,is1,is2,is3,ie1,ie2,ie3 9             format(15i4) endif call mpi_barrier(comm_work,ierr) enddo endif if( debug_vec(1) .ge. 2 )then do  i=0,nprocs-1 if( me .eq. i )then write(*,*)' ' write(*,*)' processor =',me do  k=lt,1,-1 write(*,7)k,idi(1),idi(2),idi(3),  & &                 ((nbr(d,j,k),j=-1,1,2),d=1,3),  & &                 (mi(d,k),d=1,3) enddo 7             format(i4,'idi=',3i4,'nbr=',3(2i4,'  '),'mi=',3i4,' ') write(*,*)'idi(s) = ',(idi(s),s=1,3) write(*,*)'dead(2), dead(1) = ',dead(2),dead(1) do  ax=1,3 write(*,*)'give_ex(ax,2)= ',give_ex(ax,2) write(*,*)'take_ex(ax,2)= ',take_ex(ax,2) enddo endif call mpi_barrier(comm_work,ierr) enddo endif k = lt return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine mg3P(u,v,r,a,c,n1,n2,n3,k) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     multigrid V-cycle routine !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1, n2, n3, k double precision u(nr),v(nv),r(nr) double precision a(0:3),c(0:3) integer j !--------------------------------------------------------------------- !     down cycle. !     restrict the residual from the find grid to the coarse !--------------------------------------------------------------------- do  k= lt, lb+1 , -1 j = k-1 call rprj3(r(ir(k)),m1(k),m2(k),m3(k),  & &        r(ir(j)),m1(j),m2(j),m3(j),k) enddo k = lb !--------------------------------------------------------------------- !     compute an approximate solution on the coarsest grid !--------------------------------------------------------------------- call zero3(u(ir(k)),m1(k),m2(k),m3(k)) call psinv(r(ir(k)),u(ir(k)),m1(k),m2(k),m3(k),c,k) do  k = lb+1, lt-1 j = k-1 !--------------------------------------------------------------------- !        prolongate from level k-1  to k !--------------------------------------------------------------------- call zero3(u(ir(k)),m1(k),m2(k),m3(k)) call interp(u(ir(j)),m1(j),m2(j),m3(j),  & &               u(ir(k)),m1(k),m2(k),m3(k),k) !--------------------------------------------------------------------- !        compute residual for level k !--------------------------------------------------------------------- call resid(u(ir(k)),r(ir(k)),r(ir(k)),m1(k),m2(k),m3(k),a,k) !--------------------------------------------------------------------- !        apply smoother !--------------------------------------------------------------------- call psinv(r(ir(k)),u(ir(k)),m1(k),m2(k),m3(k),c,k) enddo 200  continue j = lt - 1 k = lt call interp(u(ir(j)),m1(j),m2(j),m3(j),u,n1,n2,n3,k) call resid(u,v,r,n1,n2,n3,a,k) call psinv(r,u,n1,n2,n3,c,k) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine psinv( r,u,n1,n2,n3,c,k) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     psinv applies an approximate inverse as smoother:  u = u + Cr ! !     This  implementation costs  15A + 4M per result, where !     A and M denote the costs of Addition and Multiplication. !     Presuming coefficient c(3) is zero (the NPB assumes this, !     but it is thus not a general case), 2A + 1M may be eliminated, !     resulting in 13A + 3M. !     Note that this vectorizes, and is also fine for cache !     based machines. !--------------------------------------------------------------------- use mg_data implicit none integer n1,n2,n3,k double precision u(n1,n2,n3),r(n1,n2,n3),c(0:3) integer i3, i2, i1 double precision r1(m), r2(m) if (timeron) call timer_start(t_psinv) do i3=2,n3-1 do i2=2,n2-1 do i1=1,n1 r1(i1) = r(i1,i2-1,i3) + r(i1,i2+1,i3)  & &                + r(i1,i2,i3-1) + r(i1,i2,i3+1) r2(i1) = r(i1,i2-1,i3-1) + r(i1,i2+1,i3-1)  & &                + r(i1,i2-1,i3+1) + r(i1,i2+1,i3+1) enddo do i1=2,n1-1 u(i1,i2,i3) = u(i1,i2,i3)  & &                     + c(0) * r(i1,i2,i3)  & &                     + c(1) * ( r(i1-1,i2,i3) + r(i1+1,i2,i3)  & &                              + r1(i1) )  & &                     + c(2) * ( r2(i1) + r1(i1-1) + r1(i1+1) ) !--------------------------------------------------------------------- !  Assume c(3) = 0    (Enable line below if c(3) not= 0) !--------------------------------------------------------------------- !    >                     + c(3) * ( r2(i1-1) + r2(i1+1) ) !--------------------------------------------------------------------- enddo enddo enddo if (timeron) call timer_stop(t_psinv) !--------------------------------------------------------------------- !     exchange boundary points !--------------------------------------------------------------------- call comm3(u,n1,n2,n3,k) if( debug_vec(0) .ge. 1 )then call rep_nrm(u,n1,n2,n3,'   psinv',k) endif if( debug_vec(3) .ge. k )then call showall(u,n1,n2,n3) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine resid( u,v,r,n1,n2,n3,a,k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     resid computes the residual:  r = v - Au ! !     This  implementation costs  15A + 4M per result, where !     A and M denote the costs of Addition (or Subtraction) and !     Multiplication, respectively. !     Presuming coefficient a(1) is zero (the NPB assumes this, !     but it is thus not a general case), 3A + 1M may be eliminated, !     resulting in 12A + 3M. !     Note that this vectorizes, and is also fine for cache !     based machines. !--------------------------------------------------------------------- use mg_data implicit none integer n1,n2,n3,k double precision u(n1,n2,n3),v(n1,n2,n3),r(n1,n2,n3),a(0:3) integer i3, i2, i1 double precision u1(m), u2(m) if (timeron) call timer_start(t_resid) do i3=2,n3-1 do i2=2,n2-1 do i1=1,n1 u1(i1) = u(i1,i2-1,i3) + u(i1,i2+1,i3)  & &                + u(i1,i2,i3-1) + u(i1,i2,i3+1) u2(i1) = u(i1,i2-1,i3-1) + u(i1,i2+1,i3-1)  & &                + u(i1,i2-1,i3+1) + u(i1,i2+1,i3+1) enddo do i1=2,n1-1 r(i1,i2,i3) = v(i1,i2,i3)  & &                     - a(0) * u(i1,i2,i3)  & !--------------------------------------------------------------------- !  Assume a(1) = 0      (Enable 2 lines below if a(1) not= 0) !--------------------------------------------------------------------- !    >                     - a(1) * ( u(i1-1,i2,i3) + u(i1+1,i2,i3) !    >                              + u1(i1) ) !--------------------------------------------------------------------- &                     - a(2) * ( u2(i1) + u1(i1-1) + u1(i1+1) )  & &                     - a(3) * ( u2(i1-1) + u2(i1+1) ) enddo enddo enddo if (timeron) call timer_stop(t_resid) !--------------------------------------------------------------------- !     exchange boundary data !--------------------------------------------------------------------- call comm3(r,n1,n2,n3,k) if( debug_vec(0) .ge. 1 )then call rep_nrm(r,n1,n2,n3,'   resid',k) endif if( debug_vec(2) .ge. k )then call showall(r,n1,n2,n3) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine rprj3( r,m1k,m2k,m3k,s,m1j,m2j,m3j,k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     rprj3 projects onto the next coarser grid, !     using a trilinear Finite Element projection:  s = r' = P r ! !     This  implementation costs  20A + 4M per result, where !     A and M denote the costs of Addition and Multiplication. !     Note that this vectorizes, and is also fine for cache !     based machines. !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer m1k, m2k, m3k, m1j, m2j, m3j,k double precision r(m1k,m2k,m3k), s(m1j,m2j,m3j) integer j3, j2, j1, i3, i2, i1, d1, d2, d3, j double precision x1(m), y1(m), x2,y2 if (timeron) call timer_start(t_rprj3) if(m1k.eq.3)then d1 = 2 else d1 = 1 endif if(m2k.eq.3)then d2 = 2 else d2 = 1 endif if(m3k.eq.3)then d3 = 2 else d3 = 1 endif do  j3=2,m3j-1 i3 = 2*j3-d3 !        i3 = 2*j3-1 do  j2=2,m2j-1 i2 = 2*j2-d2 !           i2 = 2*j2-1 do j1=2,m1j i1 = 2*j1-d1 !             i1 = 2*j1-1 x1(i1-1) = r(i1-1,i2-1,i3  ) + r(i1-1,i2+1,i3  )  & &                 + r(i1-1,i2,  i3-1) + r(i1-1,i2,  i3+1) y1(i1-1) = r(i1-1,i2-1,i3-1) + r(i1-1,i2-1,i3+1)  & &                 + r(i1-1,i2+1,i3-1) + r(i1-1,i2+1,i3+1) enddo do  j1=2,m1j-1 i1 = 2*j1-d1 !             i1 = 2*j1-1 y2 = r(i1,  i2-1,i3-1) + r(i1,  i2-1,i3+1)  & &           + r(i1,  i2+1,i3-1) + r(i1,  i2+1,i3+1) x2 = r(i1,  i2-1,i3  ) + r(i1,  i2+1,i3  )  & &           + r(i1,  i2,  i3-1) + r(i1,  i2,  i3+1) s(j1,j2,j3) =  & &               0.5D0 * r(i1,i2,i3)  & &             + 0.25D0 * ( r(i1-1,i2,i3) + r(i1+1,i2,i3) + x2)  & &             + 0.125D0 * ( x1(i1-1) + x1(i1+1) + y2)  & &             + 0.0625D0 * ( y1(i1-1) + y1(i1+1) ) enddo enddo enddo if (timeron) call timer_stop(t_rprj3) j = k-1 call comm3(s,m1j,m2j,m3j,j) if( debug_vec(0) .ge. 1 )then call rep_nrm(s,m1j,m2j,m3j,'   rprj3',k-1) endif if( debug_vec(4) .ge. k )then call showall(s,m1j,m2j,m3j) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine interp( z,mm1,mm2,mm3,u,n1,n2,n3,k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     interp adds the trilinear interpolation of the correction !     from the coarser grid to the current approximation:  u = u + Qu' ! !     Observe that this  implementation costs  16A + 4M, where !     A and M denote the costs of Addition and Multiplication. !     Note that this vectorizes, and is also fine for cache !     based machines.  Vector machines may get slightly better !     performance however, with 8 separate "do i1" loops, rather than 4. !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer mm1, mm2, mm3, n1, n2, n3,k double precision z(mm1,mm2,mm3),u(n1,n2,n3) integer i3, i2, i1, d1, d2, d3, t1, t2, t3 ! note that m = 1037 in globals.h but for this only need to be ! 535 to handle up to 1024^3 !      integer m !      parameter( m=535 ) double precision z1(m),z2(m),z3(m) if (timeron) call timer_start(t_interp) if( n1 .ne. 3 .and. n2 .ne. 3 .and. n3 .ne. 3 ) then do  i3=1,mm3-1 do  i2=1,mm2-1 do i1=1,mm1 z1(i1) = z(i1,i2+1,i3) + z(i1,i2,i3) z2(i1) = z(i1,i2,i3+1) + z(i1,i2,i3) z3(i1) = z(i1,i2+1,i3+1) + z(i1,i2,i3+1) + z1(i1) enddo do  i1=1,mm1-1 u(2*i1-1,2*i2-1,2*i3-1)=u(2*i1-1,2*i2-1,2*i3-1)  & &                 +z(i1,i2,i3) u(2*i1,2*i2-1,2*i3-1)=u(2*i1,2*i2-1,2*i3-1)  & &                 +0.5d0*(z(i1+1,i2,i3)+z(i1,i2,i3)) enddo do i1=1,mm1-1 u(2*i1-1,2*i2,2*i3-1)=u(2*i1-1,2*i2,2*i3-1)  & &                 +0.5d0 * z1(i1) u(2*i1,2*i2,2*i3-1)=u(2*i1,2*i2,2*i3-1)  & &                 +0.25d0*( z1(i1) + z1(i1+1) ) enddo do i1=1,mm1-1 u(2*i1-1,2*i2-1,2*i3)=u(2*i1-1,2*i2-1,2*i3)  & &                 +0.5d0 * z2(i1) u(2*i1,2*i2-1,2*i3)=u(2*i1,2*i2-1,2*i3)  & &                 +0.25d0*( z2(i1) + z2(i1+1) ) enddo do i1=1,mm1-1 u(2*i1-1,2*i2,2*i3)=u(2*i1-1,2*i2,2*i3)  & &                 +0.25d0* z3(i1) u(2*i1,2*i2,2*i3)=u(2*i1,2*i2,2*i3)  & &                 +0.125d0*( z3(i1) + z3(i1+1) ) enddo enddo enddo else if(n1.eq.3)then d1 = 2 t1 = 1 else d1 = 1 t1 = 0 endif if(n2.eq.3)then d2 = 2 t2 = 1 else d2 = 1 t2 = 0 endif if(n3.eq.3)then d3 = 2 t3 = 1 else d3 = 1 t3 = 0 endif do  i3=d3,mm3-1 do  i2=d2,mm2-1 do  i1=d1,mm1-1 u(2*i1-d1,2*i2-d2,2*i3-d3)=u(2*i1-d1,2*i2-d2,2*i3-d3)  & &                 +z(i1,i2,i3) enddo do  i1=1,mm1-1 u(2*i1-t1,2*i2-d2,2*i3-d3)=u(2*i1-t1,2*i2-d2,2*i3-d3)  & &                 +0.5D0*(z(i1+1,i2,i3)+z(i1,i2,i3)) enddo enddo do  i2=1,mm2-1 do  i1=d1,mm1-1 u(2*i1-d1,2*i2-t2,2*i3-d3)=u(2*i1-d1,2*i2-t2,2*i3-d3)  & &                 +0.5D0*(z(i1,i2+1,i3)+z(i1,i2,i3)) enddo do  i1=1,mm1-1 u(2*i1-t1,2*i2-t2,2*i3-d3)=u(2*i1-t1,2*i2-t2,2*i3-d3)  & &                 +0.25D0*(z(i1+1,i2+1,i3)+z(i1+1,i2,i3)  & &                 +z(i1,  i2+1,i3)+z(i1,  i2,i3)) enddo enddo enddo do  i3=1,mm3-1 do  i2=d2,mm2-1 do  i1=d1,mm1-1 u(2*i1-d1,2*i2-d2,2*i3-t3)=u(2*i1-d1,2*i2-d2,2*i3-t3)  & &                 +0.5D0*(z(i1,i2,i3+1)+z(i1,i2,i3)) enddo do  i1=1,mm1-1 u(2*i1-t1,2*i2-d2,2*i3-t3)=u(2*i1-t1,2*i2-d2,2*i3-t3)  & &                 +0.25D0*(z(i1+1,i2,i3+1)+z(i1,i2,i3+1)  & &                 +z(i1+1,i2,i3  )+z(i1,i2,i3  )) enddo enddo do  i2=1,mm2-1 do  i1=d1,mm1-1 u(2*i1-d1,2*i2-t2,2*i3-t3)=u(2*i1-d1,2*i2-t2,2*i3-t3)  & &                 +0.25D0*(z(i1,i2+1,i3+1)+z(i1,i2,i3+1)  & &                 +z(i1,i2+1,i3  )+z(i1,i2,i3  )) enddo do  i1=1,mm1-1 u(2*i1-t1,2*i2-t2,2*i3-t3)=u(2*i1-t1,2*i2-t2,2*i3-t3)  & &                 +0.125D0*(z(i1+1,i2+1,i3+1)+z(i1+1,i2,i3+1)  & &                 +z(i1  ,i2+1,i3+1)+z(i1  ,i2,i3+1)  & &                 +z(i1+1,i2+1,i3  )+z(i1+1,i2,i3  )  & &                 +z(i1  ,i2+1,i3  )+z(i1  ,i2,i3  )) enddo enddo enddo endif if (timeron) call timer_stop(t_interp) call comm3_ex(u,n1,n2,n3,k) if( debug_vec(0) .ge. 1 )then call rep_nrm(z,mm1,mm2,mm3,'z: inter',k-1) call rep_nrm(u,n1,n2,n3,'u: inter',k) endif if( debug_vec(5) .ge. k )then call showall(z,mm1,mm2,mm3) call showall(u,n1,n2,n3) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine norm2u3(r,n1,n2,n3,rnm2,rnmu,nx0,ny0,nz0) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     norm2u3 evaluates approximations to the L2 norm and the !     uniform (or L-infinity or Chebyshev) norm, under the !     assumption that the boundaries are periodic or zero.  Add the !     boundaries in with half weight (quarter weight on the edges !     and eighth weight at the corners) for inhomogeneous boundaries. !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1, n2, n3, nx0, ny0, nz0 double precision rnm2, rnmu, r(n1,n2,n3) double precision s, a, ss integer i3, i2, i1, ierr double precision dn if (timeron) call timer_start(t_norm2u3) dn = 1.0d0*nx0*ny0*nz0 s=0.0D0 rnmu = 0.0D0 do  i3=2,n3-1 do  i2=2,n2-1 do  i1=2,n1-1 s=s+r(i1,i2,i3)**2 a=abs(r(i1,i2,i3)) if(a.gt.rnmu)rnmu=a enddo enddo enddo if (timeron) call timer_stop(t_norm2u3) if (timeron) call timer_start(t_rcomm) call mpi_allreduce(rnmu,ss,1,dp_type,  & &     mpi_max,comm_work,ierr) rnmu = ss call mpi_allreduce(s, ss, 1, dp_type,  & &     mpi_sum,comm_work,ierr) s = ss if (timeron) call timer_stop(t_rcomm) rnm2=sqrt( s / dn ) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine rep_nrm(u,n1,n2,n3,title,kk) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     report on norm !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1, n2, n3, kk double precision u(n1,n2,n3) character*8 title double precision rnm2, rnmu call norm2u3(u,n1,n2,n3,rnm2,rnmu,nx(kk),ny(kk),nz(kk)) if( me .eq. root )then write(*,7)kk,title,rnm2,rnmu 7       format(' Level',i2,' in ',a8,': norms =',D21.14,D21.14) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine comm3(u,n1,n2,n3,kk) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     comm3 organizes the communication on all borders !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1, n2, n3, kk double precision u(n1,n2,n3) integer axis if( .not. dead(kk) )then do  axis = 1, 3 if( nprocs .ne. 1) then call ready( axis, -1, kk ) call ready( axis, +1, kk ) call give3( axis, +1, u, n1, n2, n3, kk ) call give3( axis, -1, u, n1, n2, n3, kk ) call take3( axis, -1, u, n1, n2, n3 ) call take3( axis, +1, u, n1, n2, n3 ) else call comm1p( axis, u, n1, n2, n3, kk ) endif enddo else call zero3(u,n1,n2,n3) endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine comm3_ex(u,n1,n2,n3,kk) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     comm3_ex  communicates to expand the number of processors !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer n1, n2, n3, kk double precision u(n1,n2,n3) integer axis do  axis = 1, 3 if( nprocs .ne. 1 ) then if( take_ex( axis, kk ) )then call ready( axis, -1, kk ) call ready( axis, +1, kk ) call take3_ex( axis, -1, u, n1, n2, n3 ) call take3_ex( axis, +1, u, n1, n2, n3 ) endif if( give_ex( axis, kk ) )then call give3_ex( axis, +1, u, n1, n2, n3, kk ) call give3_ex( axis, -1, u, n1, n2, n3, kk ) endif else call comm1p_ex( axis, u, n1, n2, n3, kk ) endif enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine ready( axis, dir, k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     ready allocates a buffer to take in a message !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, k integer buff_id,buff_len,i,ierr buff_id = 3 + dir buff_len = nm2 do  i=1,nm2 buff(i,buff_id) = 0.0D0 enddo !--------------------------------------------------------------------- !     fake message request type !--------------------------------------------------------------------- if (timeron) call timer_start(t_comm3) msg_id(axis,dir,1) = msg_type(axis,dir) +1000*me call mpi_irecv( buff(1,buff_id), buff_len,  & &     dp_type, nbr(axis,-dir,k), msg_type(axis,dir),  & &     comm_work, msg_id(axis,dir,1), ierr) if (timeron) call timer_stop(t_comm3) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine give3( axis, dir, u, n1, n2, n3, k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     give3 sends border data out in the requested direction !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3, k, ierr double precision u( n1, n2, n3 ) integer i3, i2, i1, buff_len,buff_id buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then if( dir .eq. -1 )then do  i3=2,n3-1 do  i2=2,n2-1 buff_len = buff_len + 1 buff(buff_len,buff_id ) = u( 2,  i2,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i3=2,n3-1 do  i2=2,n2-1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( n1-1, i2,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif if( axis .eq.  2 )then if( dir .eq. -1 )then do  i3=2,n3-1 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,  2,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i3=2,n3-1 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len,  buff_id )= u( i1,n2-1,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif if( axis .eq.  3 )then if( dir .eq. -1 )then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,2) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,n3-1) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine take3( axis, dir, u, n1, n2, n3 ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     take3 copies in border data from the requested direction !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3 double precision u( n1, n2, n3 ) integer buff_id, indx integer status(mpi_status_size), ierr integer i3, i2, i1 if (timeron) call timer_start(t_comm3) call mpi_wait( msg_id( axis, dir, 1 ),status,ierr) if (timeron) call timer_stop(t_comm3) buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then if( dir .eq. -1 )then do  i3=2,n3-1 do  i2=2,n2-1 indx = indx + 1 u(n1,i2,i3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i3=2,n3-1 do  i2=2,n2-1 indx = indx + 1 u(1,i2,i3) = buff(indx, buff_id ) enddo enddo endif endif if( axis .eq.  2 )then if( dir .eq. -1 )then do  i3=2,n3-1 do  i1=1,n1 indx = indx + 1 u(i1,n2,i3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i3=2,n3-1 do  i1=1,n1 indx = indx + 1 u(i1,1,i3) = buff(indx, buff_id ) enddo enddo endif endif if( axis .eq.  3 )then if( dir .eq. -1 )then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,n3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,1) = buff(indx, buff_id ) enddo enddo endif endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine give3_ex( axis, dir, u, n1, n2, n3, k ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     give3_ex sends border data out to expand number of processors !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3, k, ierr double precision u( n1, n2, n3 ) integer i3, i2, i1, buff_len, buff_id buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then if( dir .eq. -1 )then do  i3=1,n3 do  i2=1,n2 buff_len = buff_len + 1 buff(buff_len,buff_id ) = u( 2,  i2,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i3=1,n3 do  i2=1,n2 do  i1=n1-1,n1 buff_len = buff_len + 1 buff(buff_len,buff_id)= u(i1,i2,i3) enddo enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif if( axis .eq.  2 )then if( dir .eq. -1 )then do  i3=1,n3 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,  2,i3) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i3=1,n3 do  i2=n2-1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len,buff_id )= u(i1,i2,i3) enddo enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif if( axis .eq.  3 )then if( dir .eq. -1 )then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,2) enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) else if( dir .eq. +1 ) then do  i3=n3-1,n3 do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,i3) enddo enddo enddo if (timeron) call timer_start(t_comm3) call mpi_send(  & &           buff(1, buff_id ), buff_len,dp_type,  & &           nbr( axis, dir, k ), msg_type(axis,dir),  & &           comm_work, ierr) if (timeron) call timer_stop(t_comm3) endif endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine take3_ex( axis, dir, u, n1, n2, n3 ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     take3_ex copies in border data to expand number of processors !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3 double precision u( n1, n2, n3 ) integer buff_id, indx integer status(mpi_status_size) , ierr integer i3, i2, i1 if (timeron) call timer_start(t_comm3) call mpi_wait( msg_id( axis, dir, 1 ),status,ierr) if (timeron) call timer_stop(t_comm3) buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then if( dir .eq. -1 )then do  i3=1,n3 do  i2=1,n2 indx = indx + 1 u(n1,i2,i3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i3=1,n3 do  i2=1,n2 do  i1=1,2 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif endif if( axis .eq.  2 )then if( dir .eq. -1 )then do  i3=1,n3 do  i1=1,n1 indx = indx + 1 u(i1,n2,i3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i3=1,n3 do  i2=1,2 do  i1=1,n1 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif endif if( axis .eq.  3 )then if( dir .eq. -1 )then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,n3) = buff(indx, buff_id ) enddo enddo else if( dir .eq. +1 ) then do  i3=1,2 do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine comm1p( axis, u, n1, n2, n3, kk ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3 double precision u( n1, n2, n3 ) integer i3, i2, i1, buff_len,buff_id integer i, kk, indx dir = -1 buff_id = 3 + dir buff_len = nm2 do  i=1,nm2 buff(i,buff_id) = 0.0D0 enddo dir = +1 buff_id = 3 + dir buff_len = nm2 do  i=1,nm2 buff(i,buff_id) = 0.0D0 enddo dir = +1 buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then do  i3=2,n3-1 do  i2=2,n2-1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( n1-1, i2,i3) enddo enddo endif if( axis .eq.  2 )then do  i3=2,n3-1 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len,  buff_id )= u( i1,n2-1,i3) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,n3-1) enddo enddo endif dir = -1 buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then do  i3=2,n3-1 do  i2=2,n2-1 buff_len = buff_len + 1 buff(buff_len,buff_id ) = u( 2,  i2,i3) enddo enddo endif if( axis .eq.  2 )then do  i3=2,n3-1 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,  2,i3) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,2) enddo enddo endif do  i=1,nm2 buff(i,4) = buff(i,3) buff(i,2) = buff(i,1) enddo dir = -1 buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then do  i3=2,n3-1 do  i2=2,n2-1 indx = indx + 1 u(n1,i2,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  2 )then do  i3=2,n3-1 do  i1=1,n1 indx = indx + 1 u(i1,n2,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,n3) = buff(indx, buff_id ) enddo enddo endif dir = +1 buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then do  i3=2,n3-1 do  i2=2,n2-1 indx = indx + 1 u(1,i2,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  2 )then do  i3=2,n3-1 do  i1=1,n1 indx = indx + 1 u(i1,1,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,1) = buff(indx, buff_id ) enddo enddo endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine comm1p_ex( axis, u, n1, n2, n3, kk ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mg_data use mpinpb implicit none integer axis, dir, n1, n2, n3 double precision u( n1, n2, n3 ) integer i3, i2, i1, buff_len,buff_id integer i, kk, indx if( take_ex( axis, kk ) ) then dir = -1 buff_id = 3 + dir buff_len = nm2 do  i=1,nm2 buff(i,buff_id) = 0.0D0 enddo dir = +1 buff_id = 3 + dir buff_len = nm2 do  i=1,nm2 buff(i,buff_id) = 0.0D0 enddo dir = -1 buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then do  i3=1,n3 do  i2=1,n2 indx = indx + 1 u(n1,i2,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  2 )then do  i3=1,n3 do  i1=1,n1 indx = indx + 1 u(i1,n2,i3) = buff(indx, buff_id ) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,n3) = buff(indx, buff_id ) enddo enddo endif dir = +1 buff_id = 3 + dir indx = 0 if( axis .eq.  1 )then do  i3=1,n3 do  i2=1,n2 do  i1=1,2 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif if( axis .eq.  2 )then do  i3=1,n3 do  i2=1,2 do  i1=1,n1 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif if( axis .eq.  3 )then do  i3=1,2 do  i2=1,n2 do  i1=1,n1 indx = indx + 1 u(i1,i2,i3) = buff(indx,buff_id) enddo enddo enddo endif endif if( give_ex( axis, kk ) )then dir = +1 buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then do  i3=1,n3 do  i2=1,n2 do  i1=n1-1,n1 buff_len = buff_len + 1 buff(buff_len,buff_id)= u(i1,i2,i3) enddo enddo enddo endif if( axis .eq.  2 )then do  i3=1,n3 do  i2=n2-1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len,buff_id )= u(i1,i2,i3) enddo enddo enddo endif if( axis .eq.  3 )then do  i3=n3-1,n3 do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,i3) enddo enddo enddo endif dir = -1 buff_id = 2 + dir buff_len = 0 if( axis .eq.  1 )then do  i3=1,n3 do  i2=1,n2 buff_len = buff_len + 1 buff(buff_len,buff_id ) = u( 2,  i2,i3) enddo enddo endif if( axis .eq.  2 )then do  i3=1,n3 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,  2,i3) enddo enddo endif if( axis .eq.  3 )then do  i2=1,n2 do  i1=1,n1 buff_len = buff_len + 1 buff(buff_len, buff_id ) = u( i1,i2,2) enddo enddo endif endif do  i=1,nm2 buff(i,4) = buff(i,3) buff(i,2) = buff(i,1) enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine zran3(z,n1,n2,n3,nx,ny,k) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     zran3  loads +1 at ten randomly chosen points, !     loads -1 at a different ten random points, !     and zero elsewhere. !--------------------------------------------------------------------- use mg_data, only : is1, is2, is3, ie1, ie2, ie3 use mpinpb implicit none integer n1, n2, n3, k, nx, ny, ierr, i0, m0, m1 double precision z(n1,n2,n3) integer mm, i1, i2, i3, d1, e1, e2, e3 double precision x, a double precision xx, x0, x1, a1, a2, ai, power parameter( mm = 10,  a = 5.D0 ** 13, x = 314159265.D0) double precision ten( mm, 0:1 ), temp, best integer i, j1( mm, 0:1 ), j2( mm, 0:1 ), j3( mm, 0:1 ) integer jg( 0:3, mm, 0:1 ), jg_temp(4) external randlc double precision randlc, rdummy a1 = power( a, nx, 1, 0 ) a2 = power( a, nx, ny, 0 ) call zero3(z,n1,n2,n3) !      i = is1-2+nx*(is2-2+ny*(is3-2)) ai = power( a, nx, is2-2+ny*(is3-2), is1-2 ) d1 = ie1 - is1 + 1 e1 = ie1 - is1 + 2 e2 = ie2 - is2 + 2 e3 = ie3 - is3 + 2 x0 = x rdummy = randlc( x0, ai ) do  i3 = 2, e3 x1 = x0 do  i2 = 2, e2 xx = x1 call vranlc( d1, xx, a, z( 2, i2, i3 )) rdummy = randlc( x1, a1 ) enddo rdummy = randlc( x0, a2 ) enddo !--------------------------------------------------------------------- !       call comm3(z,n1,n2,n3) !       call showall(z,n1,n2,n3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     each processor looks for twenty candidates !--------------------------------------------------------------------- do  i=1,mm ten( i, 1 ) = 0.0D0 j1( i, 1 ) = 0 j2( i, 1 ) = 0 j3( i, 1 ) = 0 ten( i, 0 ) = 1.0D0 j1( i, 0 ) = 0 j2( i, 0 ) = 0 j3( i, 0 ) = 0 enddo do  i3=2,n3-1 do  i2=2,n2-1 do  i1=2,n1-1 if( z(i1,i2,i3) .gt. ten( 1, 1 ) )then ten(1,1) = z(i1,i2,i3) j1(1,1) = i1 j2(1,1) = i2 j3(1,1) = i3 call bubble( ten, j1, j2, j3, mm, 1 ) endif if( z(i1,i2,i3) .lt. ten( 1, 0 ) )then ten(1,0) = z(i1,i2,i3) j1(1,0) = i1 j2(1,0) = i2 j3(1,0) = i3 call bubble( ten, j1, j2, j3, mm, 0 ) endif enddo enddo enddo call mpi_barrier(comm_work,ierr) !--------------------------------------------------------------------- !     Now which of these are globally best? !--------------------------------------------------------------------- i1 = mm i0 = mm do  i=mm,1,-1 best = z( j1(i1,1), j2(i1,1), j3(i1,1) ) call mpi_allreduce(best,temp,1,dp_type,  & &        mpi_max,comm_work,ierr) best = temp if(best.eq.z(j1(i1,1),j2(i1,1),j3(i1,1)))then jg( 0, i, 1) = me jg( 1, i, 1) = is1 - 2 + j1( i1, 1 ) jg( 2, i, 1) = is2 - 2 + j2( i1, 1 ) jg( 3, i, 1) = is3 - 2 + j3( i1, 1 ) i1 = i1-1 else jg( 0, i, 1) = 0 jg( 1, i, 1) = 0 jg( 2, i, 1) = 0 jg( 3, i, 1) = 0 endif ten( i, 1 ) = best call mpi_allreduce(jg(0,i,1), jg_temp,4,MPI_INTEGER,  & &        mpi_max,comm_work,ierr) jg( 0, i, 1) =  jg_temp(1) jg( 1, i, 1) =  jg_temp(2) jg( 2, i, 1) =  jg_temp(3) jg( 3, i, 1) =  jg_temp(4) best = z( j1(i0,0), j2(i0,0), j3(i0,0) ) call mpi_allreduce(best,temp,1,dp_type,  & &        mpi_min,comm_work,ierr) best = temp if(best.eq.z(j1(i0,0),j2(i0,0),j3(i0,0)))then jg( 0, i, 0) = me jg( 1, i, 0) = is1 - 2 + j1( i0, 0 ) jg( 2, i, 0) = is2 - 2 + j2( i0, 0 ) jg( 3, i, 0) = is3 - 2 + j3( i0, 0 ) i0 = i0-1 else jg( 0, i, 0) = 0 jg( 1, i, 0) = 0 jg( 2, i, 0) = 0 jg( 3, i, 0) = 0 endif ten( i, 0 ) = best call mpi_allreduce(jg(0,i,0), jg_temp,4,MPI_INTEGER,  & &        mpi_max,comm_work,ierr) jg( 0, i, 0) =  jg_temp(1) jg( 1, i, 0) =  jg_temp(2) jg( 2, i, 0) =  jg_temp(3) jg( 3, i, 0) =  jg_temp(4) enddo m1 = i1+1 m0 = i0+1 !      if( me .eq. root) then !         write(*,*)' ' !         write(*,*)' negative charges at' !         write(*,9)(jg(1,i,0),jg(2,i,0),jg(3,i,0),i=1,mm) !         write(*,*)' positive charges at' !         write(*,9)(jg(1,i,1),jg(2,i,1),jg(3,i,1),i=1,mm) !         write(*,*)' small random numbers were' !         write(*,8)(ten( i,0),i=mm,1,-1) !         write(*,*)' and they were found on processor number' !         write(*,7)(jg(0,i,0),i=mm,1,-1) !         write(*,*)' large random numbers were' !         write(*,8)(ten( i,1),i=mm,1,-1) !         write(*,*)' and they were found on processor number' !         write(*,7)(jg(0,i,1),i=mm,1,-1) !      endif ! 9    format(5(' (',i3,2(',',i3),')')) ! 8    format(5D15.8) ! 7    format(10i4) call mpi_barrier(comm_work,ierr) do  i3=1,n3 do  i2=1,n2 do  i1=1,n1 z(i1,i2,i3) = 0.0D0 enddo enddo enddo do  i=mm,m0,-1 z( j1(i,0), j2(i,0), j3(i,0) ) = -1.0D0 enddo do  i=mm,m1,-1 z( j1(i,1), j2(i,1), j3(i,1) ) = +1.0D0 enddo call comm3(z,n1,n2,n3,k) !--------------------------------------------------------------------- !          call showall(z,n1,n2,n3) !--------------------------------------------------------------------- return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine show_l(z,n1,n2,n3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mpinpb implicit none integer n1,n2,n3,i1,i2,i3,ierr double precision z(n1,n2,n3) integer m1, m2, m3,i m1 = min(n1,18) m2 = min(n2,14) m3 = min(n3,18) write(*,*)'  ' do  i=0,nprocs-1 if( me .eq. i )then write(*,*)' id = ', me do  i3=1,m3 do  i1=1,m1 write(*,6)(z(i1,i2,i3),i2=1,m2) enddo write(*,*)' - - - - - - - ' enddo write(*,*)'  ' 6          format(6f15.11) endif call mpi_barrier(comm_work,ierr) enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine showall(z,n1,n2,n3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mpinpb implicit none integer n1,n2,n3,i1,i2,i3,i,ierr double precision z(n1,n2,n3) integer m1, m2, m3 m1 = min(n1,18) m2 = min(n2,14) m3 = min(n3,18) write(*,*)'  ' do  i=0,nprocs-1 if( me .eq. i )then write(*,*)' id = ', me do  i3=1,m3 do  i1=1,m1 write(*,6)(z(i1,i2,i3),i2=1,m2) enddo write(*,*)' - - - - - - - ' enddo write(*,*)'  ' 6          format(15f6.3) endif call mpi_barrier(comm_work,ierr) enddo return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine show(z,n1,n2,n3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mpinpb implicit none integer n1,n2,n3,i1,i2,i3,ierr,i double precision z(n1,n2,n3) write(*,*)'  ' do  i=0,nprocs-1 if( me .eq. i )then write(*,*)' id = ', me do  i3=2,n3-1 do  i1=2,n1-1 write(*,6)(z(i1,i2,i3),i2=2,n1-1) enddo write(*,*)' - - - - - - - ' enddo write(*,*)'  ' 6          format(8D10.3) endif call mpi_barrier(comm_work,ierr) enddo !     call comm3(z,n1,n2,n3) return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- double precision function power( a, n1, n2, n3 ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     power  raises an integer, disguised as a double !     precision real, to an integer power. !     This version tries to avoid integer overflow by treating !     it as expressed in a form of "n1*n2+n3". !--------------------------------------------------------------------- implicit none double precision a, aj integer n1, n2, n3 integer n1j, n2j, nj external randlc double precision randlc, rdummy power = 1.0d0 aj = a nj = n3 n1j = n1 n2j = n2 100  continue if( n2j .gt. 0 ) then if( mod(n2j,2) .eq. 1 ) nj = nj + n1j n2j = n2j/2 else if( nj .eq. 0 ) then go to 200 endif if( mod(nj,2) .eq. 1 ) rdummy =  randlc( power, aj ) rdummy = randlc( aj, aj ) nj = nj/2 go to 100 200  continue return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine bubble( ten, j1, j2, j3, m, ind ) !--------------------------------------------------------------------- !--------------------------------------------------------------------- !--------------------------------------------------------------------- !     bubble        does a bubble sort in direction dir !--------------------------------------------------------------------- use mpinpb implicit none integer m, ind, j1( m, 0:1 ), j2( m, 0:1 ), j3( m, 0:1 ) double precision ten( m, 0:1 ) double precision temp integer i, j_temp if( ind .eq. 1 )then do  i=1,m-1 if( ten(i,ind) .gt. ten(i+1,ind) )then temp = ten( i+1, ind ) ten( i+1, ind ) = ten( i, ind ) ten( i, ind ) = temp j_temp           = j1( i+1, ind ) j1( i+1, ind ) = j1( i,   ind ) j1( i,   ind ) = j_temp j_temp           = j2( i+1, ind ) j2( i+1, ind ) = j2( i,   ind ) j2( i,   ind ) = j_temp j_temp           = j3( i+1, ind ) j3( i+1, ind ) = j3( i,   ind ) j3( i,   ind ) = j_temp else return endif enddo else do  i=1,m-1 if( ten(i,ind) .lt. ten(i+1,ind) )then temp = ten( i+1, ind ) ten( i+1, ind ) = ten( i, ind ) ten( i, ind ) = temp j_temp           = j1( i+1, ind ) j1( i+1, ind ) = j1( i,   ind ) j1( i,   ind ) = j_temp j_temp           = j2( i+1, ind ) j2( i+1, ind ) = j2( i,   ind ) j2( i,   ind ) = j_temp j_temp           = j3( i+1, ind ) j3( i+1, ind ) = j3( i,   ind ) j3( i,   ind ) = j_temp else return endif enddo endif return end !--------------------------------------------------------------------- !--------------------------------------------------------------------- subroutine zero3(z,n1,n2,n3) !--------------------------------------------------------------------- !--------------------------------------------------------------------- use mpinpb implicit none integer n1, n2, n3 double precision z(n1,n2,n3) integer i1, i2, i3 do  i3=1,n3 do  i2=1,n2 do  i1=1,n1 z(i1,i2,i3)=0.0D0 enddo enddo enddo return end !----- end of program ------------------------------------------------
